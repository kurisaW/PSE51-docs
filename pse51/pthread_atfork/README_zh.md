# pthread_atfork

## 名称

pthread_atfork - 注册 fork 处理函数

## 概要

```c
#include <pthread.h>

int pthread_atfork(void (*prepare)(void), void (*parent)(void), void (*child)(void));
```

## 描述

以下章节为说明性内容。

### 基本原理

在多线程程序中，`fork()` 的语义至少存在两个严重问题。一个问题与互斥锁保护的状态（例如内存）有关。考虑这样的情况：一个线程锁定了互斥锁且该互斥锁保护的状态处于不一致状态，而另一个线程调用 `fork()`。在子进程中，互斥锁处于锁定状态（由不存在的线程锁定，因此永远无法解锁）。让子进程简单地重新初始化互斥锁是不能令人满意的，因为这种方法没有解决如何纠正或处理子进程中的不一致状态的问题。

建议使用 `fork()` 的程序在子进程中紧接着调用 `exec` 函数，从而重置所有状态。在此期间，只有简短的异步信号安全库例程列表可以保证可用。

不幸的是，这个解决方案没有满足多线程库的需求。应用程序可能不知道正在使用多线程库，它们可以在 `fork()` 和 `exec` 调用之间随意调用任意数量的库例程，就像它们一直以来那样。实际上，它们可能是现有的单线程程序，因此不能期望它们遵守线程库施加的新限制。

另一方面，多线程库需要一种方法来在 `fork()` 期间保护其内部状态，以防它在子进程的后续执行中被重新进入。这个问题在多线程 I/O 库中尤为突出，这些库几乎肯定会在 `fork()` 和 `exec` 调用之间被调用来实现 I/O 重定向。解决方案可能需要在 `fork()` 期间锁定互斥锁变量，或者它可能需要在 `fork()` 处理完成后在子进程中简单地重置状态。

`pthread_atfork()` 函数旨在为多线程库提供一种保护自己免受调用 `fork()` 的无辜应用程序影响的方法，并为多线程应用程序提供一种标准机制，以保护自己免受库例程或应用程序本身中的 `fork()` 调用的影响。

预期的用法是：prepare 处理函数将获取所有互斥锁，其他两个 fork 处理函数将释放它们。

例如，应用程序可以提供一个 prepare 例程来获取库维护的必要互斥锁，并提供释放这些互斥锁的 child 和 parent 例程，从而确保子进程能够获得库状态的一致快照（并且不会留下任何孤立的互斥锁）。这在理论上是好的，但在现实中不实用。必须定位并锁定进程中的每一个互斥锁和锁。程序的每个组件，包括第三方组件，都必须参与，并且它们必须就谁负责哪个互斥锁或锁达成一致。这对于动态分配内存中的互斥锁和锁尤其成问题。实现内部的所有互斥锁和锁也必须被锁定。这可能会延迟调用 `fork()` 的线程很长时间甚至无限期延迟，因为这些同步对象的使用可能不受应用程序控制。这里要提到的最后一个问题是锁定流的问题。至少系统控制下的流（如 `stdin`、`stdout`、`stderr`）必须通过使用 `flockfile()` 锁定流来保护。但应用程序本身可能已经这样做了，可能在同一个调用 `fork()` 的线程中。在这种情况下，进程将发生死锁。

或者，一些库可能能够只提供一个 `child` 例程，将库中的互斥锁和所有相关状态重新初始化为某个已知值（例如，镜像最初执行时的状态）。但是，这种方法是不可能的，因为如果互斥锁或锁仍然被锁定，实现允许失败互斥锁和锁的 `*_init_()` 和 `*_destroy_()` 调用。在这种情况下，`child` 例程无法重新初始化互斥锁和锁。

当调用 `fork()` 时，只有调用线程在子进程中被复制。同步变量在子进程中保持与调用 `fork()` 时在父进程中相同的状态。因此，例如，互斥锁可能由在子进程中不再存在的线程持有，并且任何相关状态可能不一致。预期是父进程可以通过显式代码来避免这种情况，这些代码通过 `pthread_atfork()` 获取和释放对子进程关键的锁。此外，任何关键线程都需要在子进程中重新创建并重新初始化到适当状态（也通过 `pthread_atfork()`）。

更高级别的包可能在调用低级包之前对其自己的数据结构获取锁。在这种情况下，为 fork 处理函数调用指定的顺序允许一个简单的初始化规则来避免包死锁：包在为自己调用 `pthread_atfork()` 函数之前初始化它依赖的所有包。

如上所述，对于需要通过互斥锁和锁来保护非原子操作的功能，没有合适的解决方案。这就是为什么自 1996 年发布以来 POSIX.1 标准要求在多线程进程中 `fork()` 后的子进程只调用异步信号安全接口。

当调用 `pthread_atfork()` 为使用 `dlopen()` 加载的库中的函数注册时，会出现另一个问题。如果使用 `dlclose()` 卸载库，并且 `dlclose()` 的实现没有取消注册该函数，那么当 `fork()` 尝试调用它时，结果将是未定义行为。一些 `dlclose()` 的实现确实取消注册 `pthread_atfork()` 处理函数，但可移植应用程序不能依赖于此。该标准没有提供可移植的方法来取消注册通过 `pthread_atfork()` 安装为处理函数的函数。

## 另请参见

- [`exec`](https://pubs.opengroup.org/onlinepubs/9799919799/functions/exec.html)
- [`fork`](https://pubs.opengroup.org/onlinepubs/9799919799/functions/fork.html)
- [`flockfile`](https://pubs.opengroup.org/onlinepubs/9799919799/functions/flockfile.html)
- [`dlopen`](https://pubs.opengroup.org/onlinepubs/9799919799/functions/dlopen.html)
- [`dlclose`](https://pubs.opengroup.org/onlinepubs/9799919799/functions/dlclose.html)