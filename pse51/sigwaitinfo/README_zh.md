# sigtimedwait, sigwaitinfo — 等待排队信号

## SYNOPSIS（函数概要）

```c
#include <signal.h>

int sigtimedwait(const sigset_t *restrict set,
                 siginfo_t *restrict info,
                 const struct timespec *restrict timeout);

int sigwaitinfo(const sigset_t *restrict set,
                siginfo_t *restrict info);
```

## DESCRIPTION（描述）

`sigtimedwait()` 函数应等同于 `sigwaitinfo()`，不同之处在于：如果 `set` 指定的信号都没有挂起，`sigtimedwait()` 应等待 `timeout` 引用的 `timespec` 结构体中指定的时间间隔。如果 `timeout` 指向的 `timespec` 结构体为零值且 `set` 指定的信号都没有挂起，那么 `sigtimedwait()` 应立即返回并带有错误。如果 `timeout` 是空指针，则行为未指定。应使用 CLOCK_MONOTONIC 时钟来测量 `timeout` 参数指定的时间间隔。

`sigwaitinfo()` 函数从 `set` 指定的集合中选择挂起的信号。如果在 SIGRTMIN 到 SIGRTMAX 范围内有多个挂起信号被选中，应为编号最小的那个。实时信号和非实时信号之间，或多个挂起的非实时信号之间的选择顺序是未指定的。如果在调用时 `set` 中没有信号挂起，调用线程应被挂起，直到 `set` 中的一个或多个信号变为挂起，或者被一个未阻塞的、已捕获的信号中断。

`sigwaitinfo()` 函数应等同于 `sigwait()` 函数，不同之处在于返回值和错误报告方法不同（参见 RETURN VALUE），并且如果 `info` 参数非空，选中的信号编号应存储在 `si_signo` 成员中，信号的原因应存储在 `si_code` 成员中。如果有任何值排队到选中的信号，第一个这样的排队值应被出队，并且如果 `info` 参数非空，该值应存储在 `info` 的 `si_value` 成员中。用于排队信号的系统资源应被释放并返回给系统供其他用途。如果没有值排队，`si_value` 成员的内容是未定义的。如果没有进一步信号排队到选中的信号，该信号的挂起指示应被重置。

## RETURN VALUE（返回值）

成功完成时（即 `set` 指定的信号之一是挂起的或生成的），`sigwaitinfo()` 和 `sigtimedwait()` 应返回选中的信号编号。否则，函数应返回值 -1 并设置 `errno` 以指示错误。

## ERRORS（错误）

`sigtimedwait()` 函数可能在以下情况失败：

- **[EAGAIN]**
  - 在指定的超时期限内没有生成 `set` 指定的信号。

`sigtimedwait()` 和 `sigwaitinfo()` 函数可能在以下情况失败：

- **[EINTR]**
  - 等待被未阻塞的、已捕获的信号中断。应在系统文档中记录此错误是否导致这些函数失败。

`sigtimedwait()` 函数也可能在以下情况失败：

- **[EINVAL]**
  - `timeout` 参数指定的 `tv_nsec` 值小于零或大于等于 10 亿。

实现应仅在 `set` 中没有信号挂起且需要等待时才检查此错误。

## APPLICATION USAGE（应用程序使用）

`sigtimedwait()` 函数超时并返回 [EAGAIN] 错误。应用程序开发者应注意，这与其他函数（如返回 [ETIMEDOUT] 的 `pthread_cond_timedwait()`）不一致。

请注意，为确保生成的信号被排队且传递给 `sigqueue()` 的信号值在 `si_value` 中可用，使用 `sigwaitinfo()` 或 `sigtimedwait()` 的应用程序需要为集合中的每个信号设置 SA_SIGINFO 标志（参见 2.4 信号概念）。这意味着将每个信号设置为由三参数信号捕获函数处理，即使处理程序永远不会被调用。在设置 SA_SIGINFO 标志的同时（可移植地）将信号处理程序设置为 SIG_DFL 是不可能的，因为分配给 `struct sigaction` 的 `sa_handler` 成员而不是 `sa_sigaction` 成员会导致未定义行为，并且 SIG_DFL 不需要与 `sa_sigaction` 赋值兼容。即使编译器接受将 SIG_DFL 赋值给 `sa_sigaction`，实现也不需要将此值视为特殊——它可能只是被当作信号捕获函数的地址。

## RATIONALE（基本原理）

实时系统上现有的编程实践使用暂停等待选定事件集并在行内处理发生的第一个事件（而不是在信号处理函数中）的能力。这允许应用程序以事件导向的样式编写，类似于状态机。这种编码风格对于大规模事务处理很有用，其中应用程序的总体吞吐量和清晰跟踪状态的能力比最小化单个事件处理的响应时间更重要。

可以从 POSIX.1-2024 中定义的实时信号函数机制构造一个信号等待宏函数。但是，这样的宏必须包括所有要等待信号的广义处理程序的定义。如果信号等待函数由内核提供，可以避免处理程序处理开销的很大一部分。因此，POSIX.1-2024 提供了两个信号等待函数——一个无限等待，一个带超时——作为整体实时信号函数规范的一部分。

具有超时的函数规范允许编写一个应用程序，如果没有事件发生，可以在设定的时间段后中断等待。有人认为在等待之前设置定时器事件并在等待中识别定时器事件也会实现相同的功能，但性能水平较低。由于与用户级定时器事件规范相关的性能下降，以及等待为有效事件完成后该定时器事件的后续取消，以及与用户级方法相关的潜在竞争条件处理的复杂性，包含了单独的函数。

请注意，`sigwaitinfo()` 函数的语义几乎与 POSIX.1-2024 定义的 `sigwait()` 函数相同。唯一的区别是 `sigwaitinfo()` 在 `value` 参数中返回排队的信号值。返回排队值是必需的，以便应用程序可以区分排队到同一信号编号的多个事件。

保留两个不同的函数是因为一些实现可能选择实现 POSIX 线程扩展函数而不实现排队信号扩展。但请注意，如果 `value` 参数为 NULL，`sigwaitinfo()` 不会返回排队值，所以 POSIX 线程扩展 `sigwait()` 函数可以作为 `sigwaitinfo()` 的宏实现。

将 `sigtimedwait()` 函数从 `sigwaitinfo()` 函数分离是为了解决关于 `timeout` 指针的重载以指示无限等待（无超时）、定时等待和立即返回的担忧，以及关于与条件等待和定时等待是独立于纯阻塞函数的其他函数一致性的担忧。`sigtimedwait()` 的语义被指定为 `sigwaitinfo()` 可以作为使用空指针作为 `timeout` 的宏实现。

`sigwait` 函数为线程提供了同步机制以等待异步生成的信号。一个重要问题是：当发送信号时，有多少个在对同一信号的 `sigwait()` 函数调用中挂起的线程应该从调用中返回。考虑了四个选择：

1. 对同一信号的多次同时 `sigwait` 函数调用返回错误。
2. 一个或多个线程返回。
3. 所有等待线程返回。
4. 正好一个线程返回。

禁止对同一信号多次调用 `sigwait()` 被认为过于限制性。"一个或多个"行为使实现符合规范的包变得容易，但代价是强迫 POSIX 线程客户端在应用程序代码中保护免受对 `sigwait()` 的多次同时调用以实现可预测的行为。有担忧认为"所有等待线程"行为会导致"信号广播风暴"，通过在一般情况下的信号复制消耗过多的 CPU 资源。此外，无法提出有说服力的例子说明传递给所有比传递给一个更简单或更强大。

因此，共识是在对信号的 `sigwait` 函数调用中挂起的正好一个线程应该在信号发生时返回。这不是一个繁重的限制，因为：

* 可以从单向等待构建多路信号等待。
* 信号只应由应用程序级代码处理，因为库例程无法猜测应用程序想要对为整个进程生成的信号做什么。
* 因此应用程序可以安排单个线程等待任何给定信号并在其到达时调用任何需要的例程。

在使用信号进行进程间通信的应用程序中，信号处理通常在一个地方完成。或者，如果信号被捕获以便进行进程清理，信号处理线程可以为应用程序的每个部分调用单独的进程清理例程。由于应用程序主代码启动了应用程序的每个部分，它处于正确的抽象级别来告诉应用程序的每个部分进行清理。

当然，存在一些编程风格，在多个线程中等待单个信号是合乎逻辑的。可以构造一个简单的 `sigwait_multiple()` 例程来实现这个目标。一个可能的实现是让每个 `sigwait_multiple()` 调用者注册为表示对一组信号感兴趣。然后调用者在线程特定的条件变量上等待。单个服务器线程在所有注册信号的并集上调用 `sigwait()` 函数。当 `sigwait()` 函数返回时，设置适当的状态并广播条件变量。新的 `sigwait_multiple()` 调用者可能导致挂起的 `sigwait()` 调用被取消并重新发出，以更新正在等待的信号集。

## FUTURE DIRECTIONS（未来方向）

无。

## SEE ALSO（另见）

- 2.4 信号概念
- 2.8.1 实时信号
- `pause()`
- `pthread_sigmask()`
- `sigaction()`
- `sigpending()`
- `sigsuspend()`
- `sigwait()`
- `<signal.h>`
- `<time.h>`

## CHANGE HISTORY（变更历史）

### 首次发布于 Issue 5
为与 POSIX 实时扩展和 POSIX 线程扩展对齐而包含。

### Issue 6
- 这些函数被标记为实时信号扩展选项的一部分。
- 应用了 Open Group 更正 U035/3。`sigwaitinfo()` 函数的 SYNOPSIS 已更正，使第二个参数为 `siginfo_t *` 类型。
- [ENOSYS] 错误条件已被删除，因为如果实现不支持实时信号扩展选项，不需要提供存根。
- 描述已为与 IEEE Std 1003.1j-2000 对齐而更新，指定如果支持 CLOCK_MONOTONIC 时钟，则用于测量超时间隔。
- `restrict` 关键字已添加到 `sigtimedwait()` 和 `sigwaitinfo()` 原型中，以与 ISO/IEC 9899:1999 标准对齐。
- 应用了 IEEE Std 1003.1-2001/Cor 2-2004，项目 XSH/TC2/D6/130，将 RETURN VALUE 部分的措辞恢复到原始基础文档中的内容（"实现应仅在 set 中没有信号挂起且需要等待时才检查此错误"）。

### Issue 7
- `sigtimedwait()` 和 `sigwaitinfo()` 函数已从实时信号扩展选项移动到基本规范。
- 应用了 POSIX.1-2008，技术更正 1，XSH/TC1-2008/0583 [392]。
- 应用了 POSIX.1-2008，技术更正 2，XSH/TC2-2008/0333 [815]。

### Issue 8
- 应用了 Austin Group 缺陷 1346，要求支持单调时钟。

---
