# pthread_cancel

## 名称

pthread_cancel — 取消线程的执行

## 概��

```c
#include <pthread.h>

int pthread_cancel(pthread_t thread);
```

## 描述

`pthread_cancel()` 函数应请求取消 `thread`。目标线程的可取消状态和类型决定了取消操作何时生效。当取消操作被执行时，`thread` 的取消清理处理程序将被调用。当最后一个取消清理处理程序返回时，`thread` 的线程特定数据析构函数将被调用。当最后一个析构函数返回时，`thread` 应被终止。请求取消僵尸线程不应被视为错误。

目标线程中的取消处理应相对于调用线程从 `pthread_cancel()` 返回异步运行。

如果 `thread` 引用使用 `thrd_create()` 创建的线程，则行为是未定义的。

## 返回值

如果成功，`pthread_cancel()` 函数应返回零；否则，应返回错���编号以指示错误。

## 错误

`pthread_cancel()` 函数不应返回 [EINTR] 错误代码。

---

*以下部分是提供信息的。*

## 示例

无。

## 应用用法

无。

## 原理

考虑了两种备选函数来向线程发送取消通知。一种是定义一个新的 SIGCANCEL 信号，该信号在传递时具有取消语义；另一种是定义新的 `pthread_cancel()` 函数，该函数会触发取消语义。

新信号的优势在于，传递标准与尝试传递信号时的标准非常相似，因此将取消通知作为信号被视为一致的。实际上，许多实现使用特殊信号来实现取消。另一方面，除了 `pthread_kill()` 之外，没有可以与此信号一起使用的信号函数，并且传递的取消信号的行为与任何先前存在的已定义信号都不相同。

特殊函数的好处包括认识到这个信号是因为相似的传递标准而被定义的，并且这是取消请求和信号之间的唯一共同行为。此外，取消传递机制不必实现为信号。与信号相比，它与语言异常机制有很强的（如果不是更强的话）相似性，如果传递机制在可见上更接近信号，这种相似性可能会被掩盖。

最终，考虑到新信号与现有信号函数的使用有如此多的例外情况，使用信号会产生误导。特殊函数解决了这个问题。这个函数被仔细定义，以便希望在信号之上提供取消函数的实现可以这样做。特殊函数还意味着实现不必使用信号来实现取消。

如果实现在线程生命周期结束后检测到使用线程 ID，建议该函数应该失败并报告 [ESRCH] 错误。

历史上的实现在使用指示僵尸线程的线程 ID 执行 `pthread_cancel()` 时的结果各不相同。一些实现指示成功，无需进一步操作，因为线程已经终止；而另一些实现则给出 [ESRCH] 错误。由于本标准中的线程生命周期定义涵盖僵尸线程，在这种情况下如上所述的 [ESRCH] 错误是不合适的，给出此错误的实现不符合规范。

使用 `pthread_cancel()` 取消使用 `thrd_create()` 创建的线程是未定义的，因为 `thrd_join()` 无法指示线程被取消。标准开发者考虑添加一个 `thrd_canceled` 枚举常量，在这种情况下 `thrd_join()` 将返回该常量。但是，这个返回值在为符合 ISO C 标准而编写的代码中是意外的，并且它也不能解决仅使用 ISO C `<threads.h>` 接口的线程（例如符合 ISO C 标准的第三方库创建的线程）无法处理被取消的问题，因为 ISO C 标准不提供取消清理处理程序。

## 未来方向

无。

## 另请参阅

- `pthread_exit()`
- `pthread_cond_clockwait()`
- `pthread_join()`
- `pthread_setcancelstate()`

XBD `<pthread.h>`

## 变更历史

### 第 5 版首次发布。为与 POSIX 线程扩展对齐而包含。

### 第 6 版

`pthread_cancel()` 函数被标记为线程选项的一部分。

### 第 7 版

`pthread_cancel()` 函数从线程选项移动到基础部分。

应用 Austin Group 解释 1003.1-2001 #142，移除 [ESRCH] 错误条件。

### 第 8 版

应用 Austin Group 缺陷 792，添加要求即将僵尸线程的线程 ID 传递给 `pthread_cancel()` 不被视为错误。

应用 Austin Group 缺陷 1302，更新页面以考虑 `<threads.h>` 接口的添加。

---
