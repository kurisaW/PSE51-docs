# mktime — 将分解时间转换为自纪元以来的时间

## 概要

```c
#include <time.h>

time_t mktime(struct tm *timeptr);
```

## 描述

`mktime()` 函数应将由 `timeptr` 指向的结构体的某些成员所表示的分解时间（以本地时间表示）转换为与 `time()` 函数返回值具有相同编码的自纪元以来的时间值。`mktime()` 函数应仅使用由 `timeptr` 指向的结构体的 `tm_year`、`tm_mon`、`tm_mday`、`tm_hour`、`tm_min`、`tm_sec` 和 `tm_isdst` 成员；这些成员的值不应被限制在 `<time.h>` 中描述的范围内。

本地时区信息应设置为如同 `mktime()` 调用了 `tzset()` 一样。

`mktime()` 函数应计算自纪元以来的秒数时间以返回，该计算应按照以下步骤通过操作 **tm** 结构体的成员来实现：

1. `tm_sec` 成员可以但不应被调整到 0 到 60（含）的范围内。对于向 `tm_sec` 添加或减去的每 60 秒，应分别保存 1 分钟的减少或增加，以供后续应用。

2. `tm_min` 成员应被调整到 0 到 59（含）的范围内，然后应用任何保存的分钟减少或增加，如有必要，重复范围调整。对于向 `tm_min` 添加或减去的每 60 分钟，应分别保存 1 小时的减少或增加，以供后续应用。

3. `tm_hour` 成员应被调整到 0 到 23（含）的范围内，然后应用任何保存的小时减少或增加，如有必要，重复范围调整。对于向 `tm_hour` 添加或减去的每 24 小时，应分别保存 1 天的减少或增加，以供后续应用。

4. `tm_mon` 成员应被调整到 0 到 11（含）的范围内。对于向 `tm_mon` 添加或减去的每 12 个月，应分别保存 1 年的减少或增加，以供后续使用。

5. `tm_mday` 成员应被调整到 1 到 31（含）的范围内，然后应用任何保存的天数减少或增加，如有必要，重复范围调整。向下调整应通过从 `tm_mon`+1 月份（该年通过将任何保存的年增加/减少加到 `tm_year`+1900 的值得到）的天数（根据公历）中减去来应用，然后将 `tm_mon` 增加 1，根据需要重复。向上调整应通过向 `tm_mon`+1 月份之前月份（该年通过将任何保存的年增加/减少加到 `tm_year`+1900 的值得到）的天数中添加来应用，然后将 `tm_mon` 减少 1，根据需要重复。在这些调整期间，如有必要，应应用步骤 4 将 `tm_mon` 值保持在 0 到 11（含）的范围内。

6. 如果 `tm_mday` 成员大于 `tm_mon`+1 月份（该年通过将任何保存的年增加/减少加到 `tm_year`+1900 的值得到）的天数，应从 `tm_mday` 中减去该天数，并将 `tm_mon` 增加 1。如果这导致 `tm_mon` 的值为 12，应应用步骤 4。

7. 应根据相关 **tm** 结构体成员的范围修正值（或成员未范围修正的原始值）计算自协调世界时纪元以来的秒数，如自纪元以来秒数的定义中给出的表达式所指定（参见 XBD 4.19 自纪元以来的秒数），其中结构和表达式中的名称（除 `tm_year` 和 `tm_yday` 外）相对应，表达式中使用的 `tm_year` 值是结构体中的 `tm_year` 加上/减去任何保存的年增加/减少，表达式中使用的 `tm_yday` 值是该年的从 0 到 365（含）的年份中的第几天，从 **tm** 结构体的 `tm_mon` 和 `tm_mday` 成员计算得出。

8. 应针对本地时区标准时间与协调世界时的偏移量修正自纪元以来的时间。

9. 应进一步修正自纪元以来的时间（如适用——见下文）夏令时。

如果时区是包括夏令时（DST）调整的时区，**tm** 结构体中 `tm_isdst` 的值控制 `mktime()` 是否通过 DST 偏移量调整计算的自纪元以来的秒数值（在进行时区调整之后），如下所示：

* 如果 `tm_isdst` 为零，`mktime()` 不应通过 DST 偏移量进一步调整自纪元以来的秒数。
* 如果 `tm_isdst` 为正数，`mktime()` 应通过 DST 偏移量进一步调整自纪元以来的秒数。
* 如果 `tm_isdst` 为负数，`mktime()` 应尝试确定指定时间是否 DST 生效；如果确定 DST 生效，它应产生与等效调用具有正 `tm_isdst` 值相同的结果，否则应产生与等效调用 `tm_isdst` 值为零相同的结果。如果分解时间指定的时间在 DST 转换时被跳过或重复，则未指定 `mktime()` 是产生与等效调用具有正 `tm_isdst` 值相同的结果，还是产生与等效调用 `tm_isdst` 值为零相同的结果。

如果 `TZ` 环境变量指定了一个地理时区，该时区的实现时区数据库包含该时区标准时间与协调世界时偏移量的历史或未来更改，并且分解时间对应于由于此类更改发生而被（或将被）跳过或重复的时间，`mktime()` 应使用更改前生效的偏移量或更改后生效的偏移量计算自纪元以来的时间值。

成功完成后，结构体的成员应设置为通过调用 `localtime()` 并以计算的自纪元以来的时间作为其参数将返回的值。

## 返回值

`mktime()` 函数应返回计算的自纪元以来的时间，编码为 **time_t** 类型的值。如果自纪元以来的时间不能表示为 **time_t** 或要在 `timeptr` 指向的结构体的 `tm_year` 成员中返回的值不能表示为 **int**，函数应返回值 (**time_t**)-1 并设置 `errno` 为 [EOVERFLOW]，并且不应更改结构体的 `tm_wday` 组件的值。

由于 (**time_t**)-1 是成功调用 `mktime()` 的有效返回值，希望检查错误情况的应用程序应在调用 `mktime()` 之前将 `tm_wday` 设置为小于 0 或大于 6 的值。返回时，如果 `tm_wday` 未更改，则发生了错误。

## 错误

`mktime()` 函数可能在以下情况下失败：

**[EOVERFLOW]**
结果无法表示。

## 示例

2001年7月4日是星期几？

```c
#include <stdio.h>
#include <time.h>

struct tm time_str;

char daybuf[20];

int main(void)
{
    time_str.tm_year = 2001 - 1900;
    time_str.tm_mon = 7 - 1;
    time_str.tm_mday = 4;
    time_str.tm_hour = 0;
    time_str.tm_min = 0;
    time_str.tm_sec = 1;
    time_str.tm_isdst = -1;
    time_str.tm_wday = -1;
    if (mktime(&time_str) == (time_t)-1 && time_str.tm_wday == -1)
        (void)puts("-未知-");
    else {
        (void)strftime(daybuf, sizeof(daybuf), "%A", &time_str);
        (void)puts(daybuf);
    }
    return 0;
}
```

## 应用程序用法

当使用 `mktime()` 向本地时区的分解时间添加或减去固定时间段（总是对应固定秒数的时间段）时，对于任意的 `TZ`，只有通过使用 `mktime()` 将原始分解时间转换为自纪元以来的时间，向该值添加或减去所需秒数，然后使用结果调用 `localtime()`，才能确保可靠的结果。在调用 `mktime()` 之前调整分解时间的替代方法，如果原始时间和更新时间位于地理时区更改的不同侧，可能会产生意外结果。在遵循不范围修正 `tm_sec` 建议的实现上（参见 DESCRIPTION 中的步骤1），也可以通过向 `tm_sec` 添加或减去所需秒数（而不修改 **tm** 结构体的任何其他成员）来确保可靠的结果。在需要移植到 **time_t** 编码不是秒数的非 POSIX 系统的应用程序中，建议使用条件编译，以便在可能时在 `mktime()` 返回值上执行调整，否则在 `tm_sec` 成员上执行调整。对于已知没有地理时区更改的时区，如 TZ=UTC0，仅使用 `mktime()` 的调整不存在此问题。

当同时进行多个调整时，`mktime()` 函数解释超出范围的 **tm** 结构体字段的方式可能不会产生预期结果。例如，如果应用程序尝试通过调用 `localtime()` 先后退一天然后再后退一年，减少 `tm_mday` 和 `tm_year`，然后调用 `mktime()`，如果在 2021-03-01 上调用，这不会产生预期结果，因为 `mktime()` 会看到提供的年份为 2020（闰年）并将 Mar 0 修正为 Feb 29，而预期的结果是 Feb 28。通过在调整顺序重要时一次执行多个调整，可以避免此类问题。

`mktime()` 处理某些调整的示例如下：

* 如果在非闰年中给出 Feb 29，它将其视为 Feb 28 之后的日期并返回 Mar 1。
* 如果给出 Feb 0，它将其视为 Feb 1 之前的日期并返回 Jan 31。
* 如果给出 21:65，它将其视为 21:59 之后的 6 分钟并返回 22:05。
* 如果在 DST 生效的时间给出 `tm_isdst`=0，它返回正的 `tm_isdst` 并适当地更改其他字段。
* 如果存在 DST 转换，其中 02:00 标准时间变为 03:00 DST，并且 `mktime()` 获得 02:30（带有负 `tm_isdst`），它将其视为 02:00 标准时间之后的 30 分钟或 03:00 DST 之前的 30 分钟，并分别返回零或正的 `tm_isdst`，并适当地更改 `tm_hour` 字段。
* 如果地理时区更改其 UTC 偏移量，使得"旧 00:00"变为"新 00:30"，并且 `mktime()` 获得 00:20，它将其视为"旧 00:00"之后的 20 分钟或"新 00:30"之前的 10 分钟，并返回适当更改的 **struct tm** 字段。

如果应用程序想要检查给定的分解时间是否是被跳过的时间，可以通过查看从 `mktime()` 获得的 `tm_mday`、`tm_hour` 和 `tm_min` 值是否与输入的相同来检查。仅检查 `tm_hour` 和 `tm_min` 可能看起来足够，但 `tm_mday` 也可能更改——而不更改 `tm_hour` 和 `tm_min`——如果例如 `TZ` 设置为"ABC12XYZ-12"（可能用于压力测试）或如果地理时区将其标准时间与协调世界时的偏移量更改了 24 小时。

## 理由

为了允许应用程序区分 (**time_t**)-1 的成功返回和 [EOVERFLOW] 错误，`mktime()` 被要求在错误时不更改 `tm_wday`。使用这种机制而不是其他函数使用的约定（应用程序在调用前将 `errno` 设置为零，调用在错误时不更改 `errno`），因为 ISO C 标准不要求 `mktime()` 在错误时设置 `errno`。ISO C 标准的下一修订版预计要求 `mktime()` 在返回 (**time_t**)-1 表示错误时不更改 `tm_wday`，并且此返回约定既用于函数返回值不能表示为 **time_t** 的情况，也用于要在 **tm** 结构体的 `tm_year` 成员中返回的值不能表示为 **int** 的情况。

DESCRIPTION 部分说 `mktime()` 将指定的分解时间转换为**一个**自纪元以来的时间值。此处使用不定冠词是必要的，因为当 `tm_isdst` 为负数且时区有夏令时转换时，分解时间与自纪元以来的时间值之间不存在一一对应的关系。

`tm_isdst` 的值如何影响 `mktime()` 行为的描述被标记为 CX，因为 ISO C 标准中的要求不明确。ISO C 标准的下一修订版预计使用与此标准中等效的措辞来说明要求。

鼓励实现不范围修正 `tm_sec`（参见 DESCRIPTION 中的步骤1），以便使对 `tm_sec` 进行调整的结果始终等同于对 `mktime()` 返回值进行相同的调整，即使原始时间和更新时间位于地理时区更改的不同侧。这为应用程序提供了一种仅使用 `mktime()` 进行可靠固定时间段调整的方法，如应用程序用法中所述。

所描述的范围修正 **tm** 结构体成员的方法使用单独的变量保存要稍后应用到其他成员的调整值，或（对于年份调整）在后续计算中使用，因为这是避免中间成员值无法表示为 **int** 的一种方法。实现可以使用其他方法；唯一的要求是 `tm_year` 是唯一可能发生 [EOVERFLOW] 错误的成员。

如果按所描述的方式实现，所描述的范围修正 `tm_mday` 的方法对于非常大的值将非常低效。可以通过观察到任何 400 年的周期总是具有相同的天数来提高效率，因此逐月修正方法最多只需要应用于 4800 个月。

## 未来方向

本标准的未来版本可能要求 `mktime()` 不执行 DESCRIPTION 中步骤1描述的 **tm** 结构体的 `tm_sec` 成员的可选范围修正。

本标准的未来版本预计添加一个类似于 `mktime()` 的 `timegm()` 函数，不同之处在于 `timeptr` 指向的 **tm** 结构体包含协调世界时（而不是本地时区）的分解时间，其中对 `localtime()` 的引用被替换为对 `gmtime()` 的引用，并且没有时区偏移量或夏令时调整。`gmtime()` 和 `timegm()` 的组合将是预期的方法来对 **time_t** 值执行算术运算并与 ISO C 标准保持兼容（其中 **time_t** 的内部结构未指定），因为尝试使用 `localtime()` 和 `mktime()` 进行此类操作可能导致意外结果。

## 参见

`asctime()`, `clock()`, `ctime()`, `difftime()`, `futimens()`, `gmtime()`, `localtime()`, `strftime()`, `strptime()`, `time()`, `tzset()`

XBD 4.19 自纪元以来的秒数，`<time.h>`

## 更改历史

首次发布于 Issue 3。包含以与 POSIX.1-1988 标准和 ANSI C 标准对齐。

### Issue 6

超出 ISO C 标准的扩展被标记。

应用 IEEE Std 1003.1-2001/Cor 2-2004，项目 XSH/TC2/D6/58，更新返回值和错误部分以将可选的 [EOVERFLOW] 错误添加为 CX 扩展。

应用 IEEE Std 1003.1-2001/Cor 2-2004，项目 XSH/TC2/D6/59，将 `tzset()` 函数添加到参见部分。

### Issue 7

应用 POSIX.1-2008，Technical Corrigendum 1，XSH/TC1-2008/0393 [104]。

应用 POSIX.1-2008，Technical Corrigendum 2，XSH/TC2-2008/0228 [724]。

### Issue 8

应用 Austin Group Defect 1253，将"Daylight Savings"更改为"Daylight Saving"。

应用 Austin Group Defect 1613，更改 `mktime()` 使用的 **tm** 结构体成员的指定方式，并阐明成功调用将成员设置为与 `localtime()` 将返回的相同值。

应用 Austin Group Defect 1614，阐明 `tm_isdst` 的处理方式以及 (**time_t**)-1 返回的条件。

应用 Austin Group Defect 1627，阐明 `mktime()` 如何从 **tm** 结构体的成员计算自纪元以来的秒数时间。
