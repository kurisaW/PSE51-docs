# fscanf, scanf, sscanf

## 概要

```c
#include <stdio.h>

int fscanf(FILE *restrict stream, const char *restrict format, ...);
int scanf(const char *restrict format, ...);
int sscanf(const char *restrict s, const char *restrict format, ...);
```

## 描述

**[CX]** 本参考页描述的功能与 ISO C 标准保持一致。此处描述的要求与 ISO C 标准之间的任何冲突都是无意的。POSIX.1-2024 标准遵循 ISO C 标准。

`fscanf()` 函数应从指定的输入 `stream` 读取。`scanf()` 函数应从标准输入流 `stdin` 读取。`sscanf()` 函数应从字符串 `s` 读取。每个函数读取字节，根据格式解释它们，并将结果存储在其参数中。每个函数期望作为参数：一个如下描述的控制字符串 `format`，以及一组指示转换后的输入应存储位置的 `pointer` 参数。如果格式的参数不足，结果是未定义的。如果格式用尽而参数仍有剩余，多余的参数应被求值，但在其他情况下被忽略。

**[CX]** 转换可以应用于参数列表中 `format` 之后的第 n 个参数，而不是下一个未使用的参数。在这种情况下，转换说明符字符 `%`（见下文）被序列 `"%n$"` 替换，其中 `n` 是范围 [1,{NL_ARGMAX}] 内的十进制整数。此功能提供了定义格式字符串的能力，该字符串以适合特定语言的顺序选择参数。在包含 `"%n$"` 形式转换说明的格式字符串中，参数列表中的编号参数是否可以从格式字符串中多次引用是未指定的。

格式可以包含转换说明的任何一种形式——即 `%` 或 `"%n$"`——但两种形式不能在单个格式字符串中混合使用。唯一的例外是 `%%` 或 `%*` 可以与 `"%n$"` 形式混合使用。当使用编号参数规范时，指定第 N 个参数需要所有前导参数，从第一个到第 (N-1) 个，都是指针。

所有形式的 `fscanf()` 函数都应允许检测输入字符串中依赖于语言的小数字符。小数字符在当前语言环境（类别 `LC_NUMERIC`）中定义。在 POSIX 语言环境中，或者在小数字符未定义的语言环境中，小数字符应默认为句点 (`'.'`)。

应用程序应确保格式是一个字符字符串，如果有初始移位状态，则开始和结束于其初始移位状态，由零个或多个指令组成。每个指令由以下之一组成：一个或多个空白字节；一个普通字符（既不是 `'%'` 也不是空白字节）；或一个转换说明。每个转换说明由字符 `'%'` **[CX]** 或字符序列 `"%n$"` 引入，之后按顺序出现以下内容：

* 一个可选的赋值抑制字符 `'*'`。
* 一个可选的非零十进制整数，指定最大字段宽度。
* **[CX]** 一个可选的赋值分配字符 `'m'`。
* 一个可选的长度修饰符，指定接收对象的大小。
* 一个指定要应用的转换类型的 `转换说明符` 字符。有效的转换说明符描述如下。

`fscanf()` 函数应依次执行格式的每个指令。当所有指令都已执行，或者如果指令失败（如下详述），函数应返回。失败被描述为输入失败（由于输入字节不可用）或匹配失败（由于输入不适当）。

由一个或多个空白字节组成的指令应通过读取输入直到第一个非空白字节来执行，该字节应保持未读状态，或者直到无法读取更多字节。该指令永不失败。

作为普通字符的指令应执行如下：从输入中读取下一个字节，并与组成指令的字节进行比较；如果比较显示它们不等效，指令应失败，不同的字节和后续字节应保持未读状态。类似地，如果文件结束、编码错误或读取错误阻止了字符被读取，指令应失败。

作为转换说明的指令定义了一组匹配的输入序列，如下所述对每个转换字符。转换说明应按以下步骤执行。

应跳过输入空白字节，除非转换说明包括 `[`、`c`、`C` 或 `n` 转换说明符。

应从输入中读取一个项，除非转换说明包括 `n` 转换说明符。输入项应定义为输入字节的最长序列（最多到任何指定的最大字段宽度，该宽度可能根据转换说明符以字符或字节测量），该序列是匹配序列的初始子序列。输入项之后的第一个字节（如果有）应保持未读状态。如果输入项的长度为 0，转换说明的执行应失败；此条件是匹配失败，除非文件结束、编码错误或读取错误阻止了从流中输入，在这种情况下是输入失败。

除了 `%` 转换说明符的情况外，输入项（或者在 `%n` 转换说明符的情况下，输入字节的计数）应被转换为适合转换字符的类型。如果输入项不是匹配序列，转换说明的执行失败；此条件是匹配失败。除非赋值被 `'*'` 抑制，转换的结果应放置在紧跟在 `format` 参数之后的第一个尚未接收转换结果的参数指向的对象中，如果转换说明由 `%` 引入，**[CX]** 或者如果在第 n 个参数中由字符序列 `"%n$"` 引入。如果此对象没有适当的类型，或者转换的结果无法在提供的空间中表示，行为是未定义的。

**[CX]** `c`、`s` 和 `[` 转换说明符应接受可选的赋值分配字符 `'m'`，这将导致分配内存缓冲区来保存转换结果。如果转换说明符是 `s` 或 `[`，分配的缓冲区应包括用于终止空字符（或宽字符）的空间。在这种情况下，对应于转换说明的参数应是指针变量的引用，该变量将接收指向分配缓冲区的指针。系统应分配缓冲区，如同调用了 `malloc()` 一样。应用程序应负责在使用后释放内存。如果没有足够的内存分配缓冲区，函数应将 `errno` 设置为 [ENOMEM]，并导致转换错误。如果函数返回 EOF，任何通过使用赋值分配字符 `'m'` 为参数成功分配的内存在函数返回前应被释放。

### 长度修饰符

长度修饰符及其含义是：

- **hh**: 指定后续的 `d`、`i`、`o`、`u`、`x`、`X` 或 `n` 转换说明符应用于类型为指向 **signed char** 或 **unsigned char** 的参数。

- **h**: 指定后续的 `d`、`i`、`o`、`u`、`x`、`X` 或 `n` 转换说明符应用于类型为指向 **short** 或 **unsigned short** 的参数。

- **l** (小写字母 L): 指定后续的 `d`、`i`、`o`、`u`、`x`、`X` 或 `n` 转换说明符应用于类型为指向 **long** 或 **unsigned long** 的参数；后续的 `a`、`A`、`e`、`E`、`f`、`F`、`g` 或 `G` 转换说明符应用于类型为指向 **double** 的参数；或者后续的 `c`、`s` 或 `[` 转换说明符应用于类型为指向 **wchar_t** 的参数。**[CX]** 如果指定了 `'m'` 赋值分配字符，转换应用于类型为指向指向 **wchar_t** 的指针的参数。

- **ll** (两个小写字母 L): 指定后续的 `d`、`i`、`o`、`u`、`x`、`X` 或 `n` 转换说明符应用于类型为指向 **long long** 或 **unsigned long long** 的参数。

- **j**: 指定后续的 `d`、`i`、`o`、`u`、`x`、`X` 或 `n` 转换说明符应用于类型为指向 **intmax_t** 或 **uintmax_t** 的参数。

- **z**: 指定后续的 `d`、`i`、`o`、`u`、`x`、`X` 或 `n` 转换说明符应用于类型为指向 **size_t** 或相应有符号整数类型的参数。

- **t**: 指定后续的 `d`、`i`、`o`、`u`、`x`、`X` 或 `n` 转换说明符应用于类型为指向 **ptrdiff_t** 或相应 **unsigned** 类型的参数。

- **L**: 指定后续的 `a`、`A`、`e`、`E`、`f`、`F`、`g` 或 `G` 转换说明符应用于类型为指向 **long double** 的参数。

如果长度修饰符与除上述指定之外的任何转换说明符一起出现，行为是未定义的。

### 转换说明符

以下转换说明符是有效的：

- **d**: 匹配一个可选有符号的十进制整数，其格式与 `strtol()` 主题序列预期的相同，`base` 参数值为 10。在没有大小修饰符的情况下，应用程序应确保相应参数是指向 **int** 的指针。

- **i**: 匹配一个可选有符号的整数，其格式与 `strtol()` 主题序列预期的相同，`base` 参数值为 0。在没有大小修饰符的情况下，应用程序应确保相应参数是指向 **int** 的指针。

- **o**: 匹配一个可选有符号的八进制整数，其格式与 `strtoul()` 主题序列预期的相同，`base` 参数值为 8。在没有大小修饰符的情况下，应用程序应确保相应参数是指向 **unsigned** 的指针。

- **u**: 匹配一个可选有符号的十进制整数，其格式与 `strtoul()` 主题序列预期的相同，`base` 参数值为 10。在没有大小修饰符的情况下，应用程序应确保相应参数是指向 **unsigned** 的指针。

- **x**: 匹配一个可选有符号的十六进制整数，其格式与 `strtoul()` 主题序列预期的相同，`base` 参数值为 16。在没有大小修饰符的情况下，应用程序应确保相应参数是指向 **unsigned** 的指针。

- **a, e, f, g**: 匹配一个可选有符号的浮点数、无穷大或 NaN，其格式与 `strtod()` 主题序列预期的相同。在没有大小修饰符的情况下，应用程序应确保相应参数是指向 **float** 的指针。

如果 `fprintf()` 函数系列生成无穷大和 NaN（以浮点格式编码的符号实体）的字符串表示以支持 IEEE Std 754-1985，`fscanf()` 函数系列应将它们识别为输入。

- **s**: 匹配一个不是空白字节的字节序列。如果未指定 `'m'` 赋值分配字符，应用程序应确保相应参数是指向 **char**、**signed char** 或 **unsigned char** 数组初始字节的指针，该数组足够大以接受序列和终止空字符代码，该代码应自动添加。**[CX]** 否则，应用程序应确保相应参数是指向指向 **char** 的指针。

如果存在 `l`（小写字母 L）限定符，输入是从初始移位状态开始的字符序列。每个字符应转换为宽字符，如同调用 `mbrtowc()` 函数一样，转换状态由在第一个字符转换前初始化为零的 **mbstate_t** 对象描述。如果未指定 `'m'` 赋值分配字符，应用程序应确保相应参数是指向 **wchar_t** 数组的指针，该数组足够大以接受序列和终止空宽字符，该字符应自动添加。**[CX]** 否则，应用程序应确保相应参数是指向指向 **wchar_t** 的指针。

- **[**: 匹配来自一组预期字节（*扫描集*）的非空字节序列。在这种情况下，应抑制对空白字节的正常跳过。如果未指定 `'m'` 赋值分配字符，应用程序应确保相应参数是指向 **char**、**signed char** 或 **unsigned char** 数组初始字节的指针，该数组足够大以接受序列和终止空字节，该字节应自动添加。**[CX]** 否则，应用程序应确保相应参数是指向指向 **char** 的指针。

如果存在 `l`（小写字母 L）限定符，输入是从初始移位状态开始的字符序列。序列中的每个字符应转换为宽字符，如同调用 `mbrtowc()` 函数一样，转换状态由在第一个字符转换前初始化为零的 **mbstate_t** 对象描述。如果未指定 `'m'` 赋值分配字符，应用程序应确保相应参数是指向 **wchar_t** 数组的指针，该数组足够大以接受序列和终止空宽字符，该字符应自动添加。**[CX]** 否则，应用程序应确保相应参数是指向指向 **wchar_t** 的指针。

转换说明包括格式字符串中直到并包括匹配的右方括号 (`']'`) 的所有后续字节。方括号之间的字节（*扫描列表*）组成扫描集，除非左方括号之后的字节是插入符 (`'^'`)，在这种情况下，扫描集包含在插入符和右方括号之间的扫描列表中未出现的所有字节。如果转换说明以 `"[]"` 或 `"[^]"` 开始，右方括号包含在扫描列表中，下一个右方括号是结束转换说明的匹配右方括号；否则，第一个右方括号是结束转换说明的那个。如果 `'-'` 在扫描列表中并且不是第一个字符，也不是第一个字符为 `'^'` 时的第二个字符，也不是最后一个字符，行为是实现定义的。

- **c**: 匹配由字段宽度指定的数量的字节序列（如果转换说明中没有字段宽度则为 1）。不添加空字节。在这种情况下，应抑制对空白字节的正常跳过。如果未指定 `'m'` 赋值分配字符，应用程序应确保相应参数是指向 **char**、**signed char** 或 **unsigned char** 数组初始字节的指针，该数组足够大以接受序列。**[CX]** 否则，应用程序应确保相应参数是指向指向 **char** 的指针。

如果存在 `l`（小写字母 L）限定符，输入应是从初始移位状态开始的字符序列。序列中的每个字符转换为宽字符，如同调用 `mbrtowc()` 函数一样，转换状态由在第一个字符转换前初始化为零的 **mbstate_t** 对象描述。不添加空宽字符。如果未指定 `'m'` 赋值分配字符，应用程序应确保相应参数是指向 **wchar_t** 数组的指针，该数组足够大以接受生成的宽字符序列。**[CX]** 否则，应用程序应确保相应参数是指向指向 **wchar_t** 的指针。

- **p**: 匹配实现定义的序列集合，该集合应与相应 `fprintf()` 函数的 `%p` 转换说明符生成的序列集合相同。应用程序应确保相应参数是指向指向 **void** 的指针。输入项的解释是实现定义的。如果输入项是同一程序执行期间先前转换的值，结果指针应与该值比较相等；否则，`%p` 转换说明符的行为是未定义的。

- **n**: 不消耗输入。应用程序应确保相应参数是指向整数的指针，该整数将被写入迄今为止通过此对 `fscanf()` 函数的调用从输入读取的字节数。`%n` 转换说明符的执行不应增加函数执行完成时返回的赋值计数。不应转换参数，但应消耗一个。如果转换说明包括赋值抑制字符或字段宽度，行为是未定义的。

- **C**: **[XSI]** 等效于 `lc`。

- **S**: **[XSI]** 等效于 `ls`。

- **%**: 匹配单个 `'%'` 字符；不发生转换或赋值。完整的转换说明应为 `%%`。

如果转换说明无效，行为是未定义的。

转换说明符 `A`、`E`、`F`、`G` 和 `X` 也是有效的，并应分别等效于 `a`、`e`、`f`、`g` 和 `x`。

### 执行规则

如果在输入期间遇到文件结束，转换应终止。如果在读取匹配当前转换说明（除了 `%n`）的任何字节之前发生文件结束（除了允许的前导空白字节），当前转换说明的执行应以输入失败终止。否则，除非当前转换说明的执行以匹配失败终止，后续转换说明（如果有）的执行应以输入失败终止。

在 `sscanf()` 中到达字符串末尾应等效于在 `fscanf()` 中遇到文件结束。

如果转换在冲突输入上终止，有问题的输入在输入中保持未读状态。任何尾随空白字节（包括换行字符）应保持未读状态，除非被转换说明匹配。字面量匹配和抑制赋值的成功只能通过 `%n` 转换说明直接确定。

**[CX]** `fscanf()` 和 `scanf()` 函数可以标记与 `stream` 关联的文件的最后数据访问时间戳以供更新。第一次成功执行使用 `stream` 的 `fgetc()`、`fgets()`、`fread()`、`getc()`、`getchar()`、`getdelim()`、`getline()`、`fscanf()` 或 `scanf()` 并返回不是由先前 `ungetc()` 调用提供的数据时，应标记最后数据访问时间戳以供更新。

## 返回值

成功完成后，这些函数应返回成功匹配和赋值的输入项的数量；在早期匹配失败的情况下，此数字可能为零。如果输入在第一次转换（如果有）完成之前结束，并且没有发生匹配失败，应返回 EOF。如果在第一次转换（如果有）完成之前发生错误，并且没有发生匹配失败，应返回 EOF **[CX]** 并设置 `errno` 以指示错误。如果发生错误，应设置流的错误指示器。

## 错误

关于 `fscanf()` 函数失败和可能失败的条件，请参考 `fgetc()` 或 `fgetwc()`。

此外，`fscanf()` 函数应在以下情况下失败：

- **[EILSEQ]** **[CX]** 输入字节序列不形成有效字符。
- **[ENOMEM]** 存储空间不足。

此外，`fscanf()` 函数可能在以下情况下失败：

- **[EINVAL]** **[CX]** 参数不足。

## 示例

### 基本示例

调用：
```c
int i, n; float x; char name[50];
n = scanf("%d%f%s", &i, &x, name);
```

使用输入行：
```
25 54.32E-1 Hamster
```

将值 3 赋给 `n`，值 25 赋给 `i`，值 5.432 赋给 `x`，`name` 包含字符串 `"Hamster"`。

### 高级示例

调用：
```c
int i; float x; char name[50];
(void) scanf("%2d%f%*d %[0123456789]", &i, &x, name);
```

使用输入：
```
56789 0123 56a72
```

将 56 赋给 `i`，789.0 赋给 `x`，跳过 0123，并将字符串 `"56\0"` 放入 `name`。下一次对 `getchar()` 的调用应返回字符 `'a'`。

### 将数据读入数组

以下调用使用 `fscanf()` 从标准输入读取三个浮点数到 `input` 数组中。

```c
float input[3];
fscanf(stdin, "%f %f %f", input, input+1, input+2);
```

## 应用程序使用

如果调用 `fscanf()` 的应用程序具有任何类型为 **wint_t** 或 **wchar_t** 的对象，它还必须包含 `<wchar.h>` 头文件以定义这些对象。

对于如同通过 `malloc()` 一样分配内存的函数，应用程序应在不再需要时通过调用 `free()` 释放此类内存。对于 `fscanf()`，这是通过使用 `'m'` 赋值分配字符分配的内存。

## 基本原理

扫描集中允许的字符集限于单字节字符。在其他类似地方，允许多字节字符，但为了与 ISO C 标准保持一致，这里没有这样做。需要此功能的应用程序可以使用相应的宽字符函数来实现所需结果。

## 未来方向

无。

## 另请参见

- `2.5 标准 I/O 流`
- `fprintf()`
- `getc()`
- `setlocale()`
- `strtod()`
- `strtol()`
- `strtoul()`
- `wcrtomb()`

### XBD 引用

- `7. 语言环境`
- `<inttypes.h>`
- `<langinfo.h>`
- `<stdio.h>`
- `<wchar.h>`

## 变更历史

### 第一次发布于 Issue 1。
源自 SVID 的 Issue 1。

### Issue 5
与 ISO/IEC 9899:1990/Amendment 1:1995 (E) 对齐。具体来说，`l`（小写字母 L）限定符现在为 `c`、`s` 和 `[` 转换说明符定义。

DESCRIPTION 更新以指示如果 `fprintf()` 函数系列可以生成无穷大和 NaN，那么它们被 `fscanf()` 系列识别。

### Issue 6
应用了 Open Group Corrigenda U021/7 和 U028/10。这些更正了文本中多次出现的 "characters"，已被术语 "bytes" 替换。

规范性文本更新以避免对应用程序要求使用术语 "must"。

为与 ISO/IEC 9899:1999 标准对齐进行以下更改：

- 更新了 `fscanf()`、`scanf()` 和 `sscanf()` 的原型。
- 更新了 DESCRIPTION。
- 添加了 `hh`、`ll`、`j`、`t` 和 `z` 长度修饰符。
- 添加了 `a`、`A` 和 `F` 转换字符。

DESCRIPTION 更新以一致地使用术语 "转换说明符" 和 "转换说明"。

### Issue 7
应用了 Austin Group Interpretation 1003.1-2001 #170。

应用了 SD5-XSH-ERN-9，将 DESCRIPTION 中的 `fscanf()` 更正为 `scanf()`。

应用了 SD5-XSH-ERN-132，添加了赋值分配字符 `'m'`。

与 `%n$` 形式转换说明相关的功能从 XSI 选项移至 Base。

进行了与支持细粒度时间戳相关的更改。

APPLICATION USAGE 部分更新以阐明内存如同通过 `malloc()` 分配。

应用了 POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0185 [302], XSH/TC1-2008/0186 [90], 和 XSH/TC1-2008/0187 [14]。XSH/TC1-2008/0186 [90] 更改了 RETURN VALUE 部分的第二句话，以与 ISO C 标准下一版本预期的措辞变更对齐。

应用了 POSIX.1-2008, Technical Corrigendum 2, XSH/TC2-2008/0135 [936]。

### Issue 8
应用了 Austin Group Defect 1163，阐明格式字符串中空白字符的处理。

应用了 Austin Group Defect 1173，阐明赋值分配字符 `'m'` 的描述。

应用了 Austin Group Defect 1302，将这些函数与 ISO/IEC 9899:2018 标准对齐。

应用了 Austin Group Defect 1330，移除了过时的接口。

应用了 Austin Group Defect 1375，将 "终止空字符" 更改为 "终止空字符（或宽字符）"。

应用了 Austin Group Defect 1562，阐明确保格式是字符字符串，开始和结束于其初始移位状态（如果有）是应用程序的责任。

应用了 Austin Group Defect 1624，更改了 RETURN VALUE 部分。