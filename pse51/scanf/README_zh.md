# scanf

## 名称

scanf, fscanf, sscanf - 扫描并格式化输入

## 概要

```c
#include <stdio.h>

int scanf(const char *format, ...);
int fscanf(FILE *stream, const char *format, ...);
int sscanf(const char *s, const char *format, ...);
```

## 描述

`fscanf()` 函数应从指定的输入流 `stream` 读取。`scanf()` 函数应从标准输入流 `stdin` 读取。`sscanf()` 函数应从字符串 `s` 读取。每个函数读取字节，根据格式解释它们，并将结果存储在其参数中。每个函数期望作为参数一个控制字符串 `format`（如下所述），以及一组指向应该存储转换输入位置的 `指针` 参数。如果格式没有足够的参数，则结果未定义。如果格式耗尽而参数仍有剩余，则应评估多余的参数，但否则忽略。

转换可以应用于参数列表中格式之后的第 n 个参数，而不是下一个未使用的参数。在这种情况下，转换说明符字符 %（见下文）被序列 "%n$" 替换，其中 n 是范围 [1,{NL_ARGMAX}] 内的十进制整数。此功能提供了定义以适合特定语言的顺序选择参数的格式字符串。在包含 "%n$" 形式转换说明的格式字符串中，未指定是否可以从格式字符串多次引用参数列表中的编号参数。

格式可以包含任一形式的转换说明——即 % 或 "%n$"——但两种形式不能在单个格式字符串中混合使用。唯一的例外是 %% 或 %* 可以与 "%n$" 形式混合使用。使用编号参数规范时，指定第 N 个参数要求所有前导参数，从第一个到第 (N-1) 个，都是指针。

所有形式的 `fscanf()` 函数都应允许在输入字符串中检测依赖于语言的小数字符。小数字符在当前语言环境（类别 LC_NUMERIC）中定义。在 POSIX 语言环境中，或在未定义小数字符的语言环境中，小数字符应默认为句点（'.'）。

### 格式字符串

应用程序应确保格式是一个字符字符串，如果有初始转换状态，则以其开始和结束，由零个或多个指令组成。每个指令由以下内容之一组成：一个或多个空白字节；一个普通字符（既不是 '%' 也不是空白字节）；或一个转换说明。每个转换说明由字符 '%' 或字符序列 "%n$" 引入，之后依次出现以下内容：

*   可选的赋值抑制字符 '*'。
*   可选的非零十进制整数，指定最大字段宽度。
*   可选的赋值分配字符 'm'。
*   可选的长度修饰符，指定接收对象的大小。
*   转换说明符字符，指定要应用的转换类型。有效的转换说明符如下所述。

### 执行过程

`fscanf()` 函数应依次执行格式的每个指令。当所有指令都已执行，或者如果指令失败（如下详述），函数应返回。失败被描述为输入失败（由于输入字节不可用）或匹配失败（由于输入不合适）。

由一个或多个空白字节组成的指令应通过读取输入直到第一个非空白字节来执行，该字节应保持未读状态，或者直到无法读取更多字节。该指令永不失败。

作为普通字符的指令应按以下方式执行：应从输入中读取下一个字节并与构成指令的字节进行比较；如果比较表明它们不等效，则指令应失败，差异和后续字节应保持未读状态。类似地，如果文件结束、编码错误或读取错误阻止读取字符，则指令应失败。

作为转换说明的指令定义了一组匹配输入序列，如下所述为每个转换字符描述。转换说明应按以下步骤执行。

应跳过输入空白字节，除非转换说明包含 [、c、C 或 n 转换说明符。

应从输入中读取项，除非转换说明包含 n 转换说明符。输入项应定义为最长输入字节序列（最多到任何指定的最大字段宽度，可能以字符或字节为单位测量，取决于转换说明符），它是匹配序列的初始子序列。输入项之后的第一个字节（如果有）应保持未读状态。如果输入项的长度为 0，则转换说明的执行应失败；此条件是匹配失败，除非文件结束、编码错误或读取错误阻止从流输入，在这种情况下是输入失败。

除了 % 转换说明符的情况外，输入项（或者在 %n 转换说明的情况下，输入字节的数量）应转换为适合转换字符的类型。如果输入项不是匹配序列，则转换说明的执行失败；此条件是匹配失败。除非由 '*' 指示赋值抑制，转换的结果应放置在格式参数之后第一个尚未接收转换结果的参数指向的对象中（如果转换说明由 % 引入），或放在第 n 个参数中（如果由字符序列 "%n$" 引入）。如果此对象没有适当的类型，或者转换结果无法在提供的空间中表示，则行为未定义。

### 赋值分配

c、s 和 [ 转换说明符应接受可选的赋值分配字符 'm'，这将导致分配内存缓冲区来保存转换结果。如果转换说明符是 s 或 [，分配的缓冲区应包括终止空字符（或宽字符）的空间。在这种情况下，对应于转换说明符的参数应该是指向指针变量的引用，该变量将接收指向分配缓冲区的指针。系统应分配缓冲区，如同调用了 `malloc()`。应用程序应负责在使用后释放内存。如果没有足够的内存来分配缓冲区，函数应将 errno 设置为 [ENOMEM] 并导致转换错误。如果函数返回 EOF，则此调用使用赋值分配字符 'm' 为参数成功分配的任何内存在函数返回前应被释放。

## 长度修饰符

长度修饰符及其含义是：

**hh**
指定后续的 d、i、o、u、x、X 或 n 转换说明符应用于指向 **signed char** 或 **unsigned char** 的参数。

**h**
指定后续的 d、i、o、u、x、X 或 n 转换说明符应用于指向 **short** 或 **unsigned short** 的参数。

**l** (ell)
指定后续的 d、i、o、u、x、X 或 n 转换说明符应用于指向 **long** 或 **unsigned long** 的参数；后续的 a、A、e、E、f、F、g 或 G 转换说明符应用于指向 **double** 的参数；或后续的 c、s 或 [ 转换说明符应用于指向 **wchar_t** 的参数。如果指定了 'm' 赋值分配字符，则转换应用于指向指向 **wchar_t** 的指针的参数。

**ll** (ell-ell)
指定后续的 d、i、o、u、x、X 或 n 转换说明符应用于指向 **long long** 或 **unsigned long long** 的参数。

**j**
指定后续的 d、i、o、u、x、X 或 n 转换说明符应用于指向 **intmax_t** 或 **uintmax_t** 的参数。

**z**
指定后续的 d、i、o、u、x、X 或 n 转换说明符应用于指向 **size_t** 或相应有符号整数类型的参数。

**t**
指定后续的 d、i、o、u、x、X 或 n 转换说明符应用于指向 **ptrdiff_t** 或相应 **unsigned** 类型的参数。

**L**
指定后续的 a、A、e、E、f、F、g 或 G 转换说明符应用于指向 **long double** 的参数。

如果长度修饰符出现在除上述指定之外的任何转换说明符中，则行为未定义。

## 转换说明符

以下转换说明符是有效的：

**d**
匹配可选有符号十进制整数，其格式与预期 `strtol()` 的基数为 10 的主题序列相同。在没有大小修饰符的情况下，应用程序应确保相应参数是指向 **int** 的指针。

**i**
匹配可选有符号整数，其格式与预期 `strtol()` 的基数为 0 的主题序列相同。在没有大小修饰符的情况下，应用程序应确保相应参数是指向 **int** 的指针。

**o**
匹配可选有符号八进制整数，其格式与预期 `strtoul()` 的基数为 8 的主题序列相同。在没有大小修饰符的情况下，应用程序应确保相应参数是指向 **unsigned** 的指针。

**u**
匹配可选有符号十进制整数，其格式与预期 `strtoul()` 的基数为 10 的主题序列相同。在没有大小修饰符的情况下，应用程序应确保相应参数是指向 **unsigned** 的指针。

**x**
匹配可选有符号十六进制整数，其格式与预期 `strtoul()` 的基数为 16 的主题序列相同。在没有大小修饰符的情况下，应用程序应确保相应参数是��向 **unsigned** 的指针。

**a, e, f, g**
匹配可选有符号浮点数、无穷大或 NaN，其格式与预期 `strtod()` 的主题序列相同。在没有大小修饰符的情况下，应用程序应确保相应参数是指向 **float** 的指针。

如果 `fprintf()` 函数族为无穷大和 NaN（以浮点格式编码的符号实体）生成字符字符串表示以支持 IEEE Std 754-1985，则 `fscanf()` 函数族应将它们识别为输入。

**s**
匹配非空白字节序列。如果未指定 'm' 赋值分配字符，应用程序应确保相应参数是指向 **char**、**signed char** 或 **unsigned char** 数组的初始字节的指针，该数组足够大以接受序列和自动添加的终止空字符代码。否则，应用程序应确保相应参数是指向指向 **char** 的指针。

如果存在 l (ell) 限定符，输入是开始于初始转换状态的字符序列。每个字符应转换为宽字符，如同通过调用 `mbrtowc()` 函数，转换状态由在第一个字符转换前初始化为零的 **mbstate_t** 对象描述。如果未指定 'm' 赋值分配字符，应用程序应确保相应参数是指向 **wchar_t** 数组的指针，该数组足够大以接受序列和自动添加的终止空宽字符。否则，应用程序应确保相应参数是指向指向 **wchar_t** 的指针。

**[**
匹配来自预期字节集合（扫描集）的非空字节序列。在这种情况下应抑制正常跳过空白字节。如果未指定 'm' 赋值分配字符，应用程序应确保相应参数是指向 **char**、**signed char** 或 **unsigned char** 数组的初始字节的指针，该数组足够大以接受序列和自动添加的终止空字节。否则，应用程序应确保相应参数是指向指向 **char** 的指针。

如果存在 l (ell) 限定符，输入是开始于初始转换状态的字符序列。序列中的每个字符应转换为宽字符，如同通过调用 `mbrtowc()` 函数，转换状态由在第一个字符转换前初始化为零的 **mbstate_t** 对象描述。如果未指定 'm' 赋值分配字符，应用程序应确保相应参数是指向 **wchar_t** 数组的指针，该数组足够大以接受序列和自动添加的终止空宽字符。否则，应用程序应确保相应参数是指向指向 **wchar_t** 的指针。

转换说明包括格式字符串中直到并包括匹配右方括号（']'）的所有后续字节。方括号之间的字节（扫描列表）构成扫描集，除非左方括号之后的字节是插入符号（'^'），在这种情况下扫描集包含所有不出现在插入符号和右方括号之间扫描列表中的字节。如果转换说明以 "[]" 或 "[^]" 开始，右方括号包含在扫描列表中，下一个右方括号是结束转换说明的匹配右方括号；否则，第一个右方括号是结束转换说明的那个。如果 '-' 在扫描列表中且不是第一个字符，也不是第一个字符为 '^' 时的第二个字符，也不是最后一个字符，则行为是实现定义的。

**c**
匹配由字段宽度指定的数字数量的字节序列（如果转换说明中没有字段宽度则为 1）。不添加空字节。在这种情况下应抑制正常跳过空白字节。如果未指定 'm' 赋值分配字符，应用程序应确保相应参数是指向 **char**、**signed char** 或 **unsigned char** 数组的初始字节的指针，该数组足够大以接受序列。否则，应用程序应确保相应参数是指向指向 **char** 的指针。

如果存在 l (ell) 限定符，输入应是开始于初始转换状态的字符序列。序列中的每个字符转换为宽字符，如同通过调用 `mbrtowc()` 函数，转换状态由在第一个字符转换前初始化为零的 **mbstate_t** 对象描述。不添加空宽字符。如果未指定 'm' 赋值分配字符，应用程序应确保相应参数是指向 **wchar_t** 数组的指针，该数组足够大以接受生成的宽字符序列。否则，应用程序应确保相应参数是指向指向 **wchar_t** 的指针。

**p**
匹配实现定义的序列集合，该集合应与相应 `fprintf()` 函数的 %p 转换说明产生的序列集合相同。应用程序应确保相应参数是指向指向 **void** 的指针。输入项的解释是实现定义的。如果输入项是在同一程序执行期间先前转换的值，则结果指针应与该值比较相等；否则，%p 转换说明的行为未定义。

**n**
不消耗输入。应用程序应确保相应参数是指向整数的指针，其中应写入到目前为止通过此调用 `fscanf()` 函数从输入读取的字节数。%n 转换说明的执行不应增加函数执行完成时返回的赋值计数。不转换参数，但应消耗一个。如果转换说明包含赋值抑制字符或字段宽度，则行为未定义。

**C**
等效于 lc。

**S**
等效于 ls。

**%**
匹配单个 '%' 字符；不发生转换或赋值。完整的转换说明应为 %%。

如果转换说明无效，则行为未定义。

转换说明符 A、E、F、G 和 X 也有效，并应分别等效于 a、e、f、g 和 x。

## 终止条件

如果在输入期间遇到文件结束，则应终止转换。如果在读取任何匹配当前转换说明（除了 %n）的字节（除了允许的前导空白字节）之前发生文件结束，则当前转换说明的执行应以输入失败终止。否则，除非当前转换说明的执行以匹配失败终止，则后续转换说明（如果有）的执行应以输入失败终止。

在 `sscanf()` 中到达字符串末尾应等效于 `fscanf()` 遇到文件结束。

如果转换在冲突输入上终止，则违规输入保留在输入中未读。任何尾随空白字节（包括换行字符）应保持未读状态，除非由转换说明匹配。文字匹配和抑制赋值的成功只能通过 %n 转换说明直接确定。

`fscanf()` 和 `scanf()` 函数可能标记与 `stream` 关联的文件的最后数据访问时间戳以进行更新。第一次成功执行使用 `stream` 并返回非先前 `ungetc()` 调用提供的数据的 `fgetc()`、`fgets()`、`fread()`、`getc()`、`getchar()`、`getdelim()`、`getline()`、`fscanf()` 或 `scanf()` 时，最后数据访问时间戳应标记为更新。

## 返回值

成功完成后，这些函数应返回成功匹配和赋值的输入项数量；在早期匹配失败的情况下此数量可以为零。如果输入在第一次匹配失败或转换之前结束，应返回 EOF。如果发生读取错误，应设置流的错误指示符，应返回 EOF，并应设置 `errno` 以指示错误。

## 错误

函数在以下情况下失败：

*   **EAGAIN** - 为 `stream` 底层的文件描述符设置了 O_NONBLOCK 标志，并且线程将在 `fscanf()` 操作中被延迟。
*   **EBADF** - `stream` 底层的文件描述符不是为读取而打开的有效文件描述符。
*   **EINTR** - 读操作由于接收信号而终止，且未传输数据。
*   **EIO** - 发生物理 I/O 错误。
*   **ENOMEM** - 存储空间不足。

`fscanf()` 和 `scanf()` 函数在以下情况下可能失败：

*   **EOVERFLOW** - 文件是常规文件，并且尝试在相应流的偏移量最大值处或超出该值进行读取。

`sscanf()` 函数在以下情况下应失败：

*   **ENAMETOOLONG** - 路径名组件的长度超过 {NAME_MAX}。

## 示例

```c
#include <stdio.h>

int main() {
    int i, j;
    float x, y;
    char s[80];

    /* 基本用法 */
    scanf("%d %f", &i, &x);

    /* 读入多个变量 */
    scanf("%d %f %s", &j, &y, s);

    /* 使用赋值抑制 */
    scanf("%*d %d", &i);  /* 跳过第一个整数，读取第二个 */

    /* 使用字段宽度 */
    scanf("%4d %4d", &i, &j);  /* 读取两个 4 位整数 */

    return 0;
}
```

## 应用程序用法

鼓励程序员使用 `fgets()` 和 `sscanf()` 而不是 `scanf()`，以避免缓冲区溢出问题并更优雅地处理输入错误。

## 基本原理

`scanf()` 函数族提供格式化输入功能，补充 `printf()` 格式化输出函数族。赋值分配功能（'m' 字符）被添加以简化可变长度字符串输入的处理。

## 未来方向

无。

## 另见

*   `fgets()`
*   `fprintf()`
*   `getc()`
*   `getdelim()`
*   `getline()`
*   `malloc()`
*   `setlocale()`
*   `strtod()`
*   `strtol()`
*   `strtoul()`

## 版权

本文的部分内容从 IEEE Std 1003.1-2024，信息技术标准 -- 便携式操作系统接口（POSIX），The Open Group 基本规范第 7 版，版权所有 (C) 2024 由电气和电子工程师协会有限公司和 The Open Group。如果此版本与原始 IEEE 和 The Open Group 标准之间存在任何差异，原始 IEEE 和 The Open Group 标准为裁判文档。原始标准可在线获取于 http://www.opengroup.org/unix/online.html。

本页中出现的任何印刷或格式错误很可能是转录原始文档信息时的错误，不是标准本身的一部分。