# sem_post — 解锁信号量

## 概要

```c
#include <semaphore.h>

int sem_post(sem_t *sem);
```

## 描述

`sem_post()` 函数应通过在由 `sem` 引用的信号量上执行信号量解锁操作来解锁该信号量。

如果此操作产生的信号量值为正值，则没有线程被阻塞等待信号量解锁；信号量值仅被简单地递增。

如果此操作产生的信号量值为零，则应允许其中一个被阻塞等待信号量的线程从其对 `sem_wait()` 的调用中成功返回。[PS] 如果支持进程调度选项，则应选择适合被阻塞线程生效的调度策略和参数的方式来选择要解除阻塞的线程。对于 SCHED_FIFO 和 SCHED_RR 调度器，应解除最高优先级等待线程的阻塞，如果有多个最高优先级线程被阻塞等待信号量，则应解除等待时间最长的最高优先级线程的阻塞。如果未定义进程调度选项，则选择要解除阻塞的线程是未指定的。

[SS] 如果支持进程零星服务器选项，且调度策略为 SCHED_SPORADIC，则语义与上述 SCHED_FIFO 相同。

`sem_post()` 函数应为异步信号安全函数，可以从信号捕获函数中调用。

## 返回值

如果成功，`sem_post()` 函数应返回零；否则，函数应返回 -1 并设置 `errno` 以指示错误。

## 错误

`sem_post()` 函数在以下情况下应失败：

- **[EOVERFLOW]** 将超过信号量的最大允许值。

`sem_post()` 函数在以下情况下可能失败：

- **[EINVAL]** `sem` 参数不引用有效的信号量。

## 示例

参见 `sem_clockwait()`。

## 应用用法

无。

## 原理

无。

## 未来方向

无。

## 参见

- `semctl()`
- `semget()`
- `semop()`
- `sem_clockwait()`
- `sem_trywait()`

XBD 4.15.2 内存同步，`<semaphore.h>`

## 变更历史

### 首次发布于 Issue 5
为与 POSIX 实时扩展对齐而包含。

### Issue 6
- `sem_post()` 函数被标记为信号量选项的一部分。
- 删除了 [ENOSYS] 错误条件，因为如果实现不支持信号量选项，则无需提供存根。
- 为与 IEEE Std 1003.1d-1999 对齐，在参见部分添加了 `sem_timedwait()` 函数。
- 为与 IEEE Std 1003.1d-1999 对齐，在指定要解除阻塞线程的调度策略列表中添加了 SCHED_SPORADIC。
- 应用了 IEEE Std 1003.1-2001/Cor 2-2004，项目 XSH/TC2/D6/119，更新错误部分，使 [EINVAL] 错误变为可选。

### Issue 7
- 应用了 Austin Group 解释 1003.1-2001 #156。
- `sem_post()` 函数从信号量选项移至基础部分。
- 应用了 POSIX.1-2008，技术勘误表 1，XSH/TC1-2008/0528 [37]。

### Issue 8
- 应用了 Austin Group 缺陷 315，添加了 [EOVERFLOW] 错误。

---
