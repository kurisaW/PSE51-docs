# read

## SYNOPSIS

```c
#include <unistd.h>

ssize_t pread(int fildes, void *buf, size_t nbyte, off_t offset);
ssize_t read(int fildes, void *buf, size_t nbyte);
```

## DESCRIPTION

`read()` 函数应尝试从与打开文件描述符 `fildes` 相关联的文件中读取 `nbyte` 字节数据到 `buf` 指向的缓冲区。对同一管道、FIFO 或终端设备进行多次并发读取的行为是未指定的。

在执行下述任何操作之前，如果 `nbyte` 为零，`read()` 函数可以检测并返回如下所述的错误。在没有错误的情况下，或者如果未执行错误检测，`read()` 函数应返回零且没有其他结果。

在支持寻址的文件（例如常规文件）上，`read()` 应从与 `fildes` 相关联的文件偏移量所指定的文件位置开始读取。文件偏移量应增加实际读取的字节数。

不支持寻址的文件（例如终端）总是从当前位置读取。与此类文件相关联的文件偏移量的值是未定义的。

不会发生超过当前文件末尾的数据传输。如果起始位置在文件末尾或之后，应返回 0。如果文件引用设备特殊文件，后续 `read()` 请求的结果是实现定义的。

如果 `nbyte` 的值大于 {SSIZE_MAX}，结果是实现定义的。

当尝试从空管道或 FIFO 读取时：

* 如果没有进程以写方式打开管道，`read()` 应返回 0 以指示文件结束。
* 如果某个进程以写方式打开管道且设置了 O_NONBLOCK，`read()` 应返回 -1 并设置 `errno` 为 [EAGAIN]。
* 如果某个进程以写方式打开管道且清除了 O_NONBLOCK，`read()` 应阻塞调用线程，直到写入某些数据或所有以写方式打开管道的进程都关闭了管道。

当尝试读取支持非阻塞读取且当前没有可用数据的文件（管道或 FIFO 除外）时：

* 如果设置了 O_NONBLOCK，`read()` 应返回 -1 并设置 `errno` 为 [EAGAIN]。
* 如果清除了 O_NONBLOCK，`read()` 应阻塞调用线程，直到某些数据变为可用。
* 如果有可用数据，使用 O_NONBLOCK 标志没有效果。

`read()` 函数读取先前写入文件的数据。如果在常规文件的文件末尾之前的任何部分尚未被写入，`read()` 应返回值为 0 的字节。例如，`lseek()` 允许文件偏移量设置到文件中现有数据之后的位置。如果稍后在此点写入数据，则在先前数据末尾和新写入数据之间的间隙中的后续读取应返回值为 0 的字节，直到数据写入到该间隙中。

成功完成时，当 `nbyte` 大于 0，`read()` 应标记要更新文件的最后数据访问时间戳，并应返回读取的字节数。此数字永远不会大于 `nbyte`。如果文件中剩余的字节数小于 `nbyte`、`read()` 请求被信号中断、或者文件是管道或 FIFO 或特殊文件且立即可用于读取的字节数少于 `nbyte`，则返回的值可能小于 `nbyte`。例如，从与终端相关联的文件的 `read()` 可能返回一个输入行的数据。

如果在 `read()` 读取任何数据之前被信号中断，它应返回 -1 并设置 `errno` 为 [EINTR]。

如果在 `read()` 成功读取某些数据后被信号中断，它应返回已读取的字节数。

对于常规文件，不会发生超过在与 `fildes` 相关联的打开文件描述中建立的偏移量最大值的数据传输。

如果 `fildes` 引用套接字，`read()` 应等同于不设置标志的 `recv()`。

[SIO] 如果设置了 O_DSYNC 和 O_RSYNC 位，文件描述符上的读取 I/O 操作应按照同步 I/O 数据完整性完成所定义的方式完成。如果设置了 O_SYNC 和 O_RSYNC 位，文件描述符上的读取 I/O 操作应按照同步 I/O 文件完整性完成所定义的方式完成。

[SHM] 如果 `fildes` 引用共享内存对象，`read()` 函数的结果是未指定的。

[TYM] 如果 `fildes` 引用类型化内存对象，`read()` 函数的结果是未指定的。

`pread()` 函数应等同于 `read()`，不同之处在于它应从文件中的给定位置读取而不改变文件偏移量。`pread()` 的前三个参数与 `read()` 相同，增加了第四个参数 `offset` 用于指定文件内期望的位置。尝试对无法寻址的文件执行 `pread()` 将导致错误。

## RETURN VALUE

成功完成时，这些函数应返回一个非负整数，指示实际读取的字节数。否则，函数应返回 -1 并设置 `errno` 以指示错误。

## ERRORS

这些函数在以下情况下可能失败：

**[EAGAIN]**
文件既不是管道，也不是 FIFO，也不是套接字，文件描述符设置了 O_NONBLOCK 标志，且线程将在读取操作中延迟。

**[EBADF]**
`fildes` 参数不是一个有效的用于读取的打开文件描述符。

**[EINTR]**
读取操作由于收到信号而终止，且没有数据被传输。

**[EIO]**
进程是后台进程组的成员，试图从其控制终端读取，并且调用线程正在阻塞 SIGTTIN，或者进程正在忽略 SIGTTIN，或者进程的进程组是孤儿进程组。此错误也可能由于实现定义的原因而生成。

**[EISDIR]**
[XSI] `fildes` 参数引用目录，且实现不允许使用 `read()` 或 `pread()` 读取目录。应使用 `readdir()` 函数代替。

**[EOVERFLOW]**
文件是常规文件，`nbyte` 大于 0，起始位置在文件结束之前，且起始位置大于或等于在与 `fildes` 相关联的打开文件描述中建立的偏移量最大值。

`pread()` 函数在以下情况下可能失败：

**[EINVAL]**
文件是常规文件或块特殊文件，且 `offset` 参数为负数。文件偏移量应保持不变。

**[ESPIPE]**
文件无法寻址。

`read()` 函数在以下情况下可能失败：

**[EAGAIN]**
文件是管道或 FIFO，文件描述符设置了 O_NONBLOCK 标志，且线程将在读取操作中延迟。

**[EAGAIN]** 或 **[EWOULDBLOCK]**
文件是套接字，文件描述符设置了 O_NONBLOCK 标志，且线程将在读取操作中延迟。

**[ECONNRESET]**
尝试在套接字上读取，但连接被其对等方强制关闭。

**[ENOTCONN]**
尝试在未连接的套接字上读取。

**[ETIMEDOUT]**
尝试在套接字上读取，但发生了传输超时。

这些函数在以下情况下可能失败：

**[EIO]**
发生了物理 I/O 错误。

**[ENOBUFS]**
系统中可用资源不足，无法执行操作。

**[ENOMEM]**
可用内存不足，无法满足请求。

**[ENXIO]**
对不存在的设备发出了请求，或者请求超出了设备的能力。

## EXAMPLES

### 将数据读入缓冲区

以下示例将数据从与文件描述符 `fd` 相关联的文件读取到 `buf` 指向的缓冲区中。

```c
#include <sys/types.h>
#include <unistd.h>
...
char buf[20];
size_t nbytes;
ssize_t bytes_read;
int fd;
...
nbytes = sizeof(buf);
bytes_read = read(fd, buf, nbytes);
...
```

## APPLICATION USAGE

无。

## RATIONALE

POSIX.1-2024 的这一卷没有指定返回错误后的文件偏移量值；情况太多。对于编程错误，如 [EBADF]，由于不涉及文件，这个概念没有意义。对于立即检测到的错误，如 [EAGAIN]，显然偏移量不应该改变。然而，在中断或硬件错误之后，更新后的值将非常有用，这也是许多实现的行为。

请注意，读取零字节的 `read()` 不会修改最后数据访问时间戳。请求读取超过零字节但返回零的 `read()` 需要修改最后数据访问时间戳。

允许实现执行对零字节 `read()` 请求的错误检查，但不是必需的。

### 输入和输出

使用大字节计数的 I/O 总是带来问题。诸如 `lread()` 和 `lwrite()`（使用和返回 `long`）的想法曾被考虑过。当前的解决方案是在 ISO C 标准函数上使用抽象类型来处理 `read()` 和 `write()`。可以声明抽象类型，以便现有函数工作，也可以声明抽象类型，以便在未来的实现中表示更大的类型。据推测，限制 `size_t` 最大范围的任何约束也将限制可移植 I/O 请求到相同范围。POSIX.1-2024 的这一卷还通过要求字节计数被限制以使有符号返回值保持有意义来进一步限制范围。由于返回类型也是（有符号的）抽象类型，字节计数可以由实现定义为大于 `int` 可以容纳的值。

标准制定者考虑为管道或 FIFO 添加原子性要求，但认识到由于管道和 FIFO 的性质，无法保证对 {PIPE_BUF} 或任何其他大小的读取的原子性，而这将有助于应用程序的可移植性。

POSIX.1-2024 的这一卷要求当 `nbyte` 为零时，`read()` 或 `write()` 不采取任何操作。这并不意图优先于错误检测（如无效的缓冲区指针或文件描述符）。这与 POSIX.1-2024 的这一卷的其余部分一致，但这里的措辞可能被误读为要求在检测到任何其他错误之前检测零情况。零值应被视为正确的值，其语义是无操作。

I/O 意图对常规文件、管道和 FIFO 是原子的。原子意味着单个操作中一起开始的所有字节最终一起结束，没有其他 I/O 操作的交错。这是终端的一个已知属性不被遵守，终端被明确地（和隐含地永久地）排除，使得行为未指定。其他设备类型的行为也未指定，但措辞意图暗示未来的标准可能选择指定原子性（或不指定）。

有建议向 `read()` 和 `write()` 添加格式参数，以处理异构文件系统和基本硬件类型之间的网络传输。这样的设施可能是 OSI 表示层服务支持所需要的。然而，确定这应该与类似的 C 语言设施相对应，而这超出了 POSIX.1-2024 的这一卷的范围。这个概念被建议给 ISO C 标准的开发者考虑，作为未来工作的可能领域。

在 4.3 BSD 中，在传输任何数据之前被信号中断的 `read()` 或 `write()` 默认不返回 [EINTR] 错误，而是被重新启动。在 4.2 BSD、4.3 BSD 和第八版中，有一个额外的函数 `select()`，其目的是暂停直到在指定的文件描述符上检测到指定的活动（要读取的数据、要写入的空间等）。在为这些系统编写的应用程序中，在由于信号而中断 I/O 的情况（如键盘输入）下，在 `read()` 之前使用 `select()` 是常见的。

哪些文件或文件类型可中断的问题被认为是实现设计问题。这通常主要受硬件和可靠性问题的影响。

没有对"不可恢复错误"之后采取的行动的引用。这被认为超出了 POSIX.1-2024 的这一卷描述硬件错误情况时发生什么的范围。

本标准的早期版本允许两种非常不同的中断处理行为。为了尽量减少由此产生的混淆，决定 POSIX.1-2024 应只支持其中一种行为。在 AT&T 衍生系统上的历史实践是，当在部分但不是所有请求的数据被传输后被中断时，`read()` 和 `write()` 返回 -1 并设置 `errno` 为 [EINTR]。然而，美国商务部 FIPS 151-1 和 FIPS 151-2 要求历史 BSD 行为，其中 `read()` 和 `write()` 返回中断前实际传输的字节数。如果在传输任何数据时返回 -1，在可寻址设备上很难从错误中恢复，在不可寻址设备上是不可能的。大多数新实现都支持这种行为。POSIX.1-2024 要求的行为是返回传输的字节数。

POSIX.1-2024 没有指定缓冲 `read()` 的实现何时实际将数据移动到用户提供的缓冲区，因此实现可以选择在最晚的时刻执行此操作。因此，较早到达的中断可能不会导致 `read()` 返回部分字节计数，而是返回 -1 并设置 `errno` 为 [EINTR]。

还考虑了结合前两个选项，设置 `errno` 为 [EINTR] 同时返回短计数。然而，不仅没有现有的实践实现这一点，它也与当设置 `errno` 时，负责的函数应返回 -1 的想法相矛盾。

POSIX.1-2024 的这一卷故意没有指定任何与管道、FIFO 和套接字相关的 `pread()` 错误，除了 [ESPIPE]。

## FUTURE DIRECTIONS

无。

## SEE ALSO

`fcntl()`, `lseek()`, `open()`, `pipe()`, `readv()`

XBD 11. General Terminal Interface, `<sys/uio.h>`, `<unistd.h>`

## CHANGE HISTORY

首次在 Issue 1 中发布。源自 SVID 的 Issue 1。

### Issue 5

DESCRIPTION 更新以与 POSIX Realtime Extension 和 POSIX Threads Extension 对齐。

添加了 Large File Summit 扩展。

添加了 `pread()` 函数。

### Issue 6

DESCRIPTION 和 ERRORS 部分更新，使得对 STREAMS 的引用被标记为 XSI STREAMS Option Group 的一部分。

以下对 POSIX 实现的新要求源自与 Single UNIX Specification 的对齐：

* DESCRIPTION 现在说明如果 `read()` 在成功读取某些数据后被信号中断，它返回读取的字节数。在 Issue 3 中，`read()` 是返回读取的字节数还是返回 -1 并设置 `errno` 为 [EINTR] 是可选的。这是一个 FIPS 要求。
* 在 DESCRIPTION 中，添加了文本以指示对于常规文件，不会发生超过在与 `fildes` 相关联的打开文件描述中建立的偏移量最大值的数据传输。此更改是为了支持大文件。
* 添加了 [EOVERFLOW] 强制错误条件。
* 添加了 [ENXIO] 可选错误条件。

添加了引用套接字的文本到 DESCRIPTION 中。

进行了以下更改以与 IEEE P1003.1a 草案标准对齐：

* 澄清了读取零字节的效果。

DESCRIPTION 通过指定对类型化内存对象的 `read()` 结果是未指定的来更新以与 IEEE Std 1003.1j-2000 对齐。

添加了新的 RATIONALE 来解释输入和输出操作的原子性要求。

为套接字操作添加了以下错误条件：[EAGAIN]、[ECONNRESET]、[ENOTCONN] 和 [ETIMEDOUT]。

[EIO] 错误设为可选。

为套接字操作添加了以下错误条件：[ENOBUFS] 和 [ENOMEM]。

`readv()` 函数被拆分为单独的参考页面。

应用 IEEE Std 1003.1-2001/Cor 2-2004，项目 XSH/TC2/D6/108，更新 ERRORS 部分中的 [EAGAIN] 错误，从"进程将被延迟"改为"线程将被延迟"。

应用 IEEE Std 1003.1-2001/Cor 2-2004，项目 XSH/TC2/D6/109，在 RATIONALE 部分进行了编辑修正。

### Issue 7

`pread()` 函数从 XSI 选项移动到 Base。

与 XSI STREAMS 选项相关的功能被标记为过时。

进行了与支持细粒度时间戳相关的更改。

应用 POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0480 [218], XSH/TC1-2008/0481 [79], XSH/TC1-2008/0482 [218], XSH/TC1-2008/0483 [218], XSH/TC1-2008/0484 [218], 和 XSH/TC1-2008/0485 [218,428]。

应用 POSIX.1-2008, Technical Corrigendum 2, XSH/TC2-2008/0302 [710] 和 XSH/TC2-2008/0303 [676,710]。

### Issue 8

应用 Austin Group Defect 1330，移除过时接口。

---

UNIX® 是 The Open Group 的注册商标。
POSIX™ 是 IEEE 的商标。
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved