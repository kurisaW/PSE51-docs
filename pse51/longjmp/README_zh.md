# longjmp — 非本地跳转

## 概要

```c
#include <setjmp.h>

_Noreturn void longjmp(jmp_buf env, int val);
```

## 描述

`longjmp()` 函数应当恢复在同一进程中由最近的 `setjmp()` 调用所保存的环境，该调用使用相应的 `jmp_buf` 参数。如果具有相应 `jmp_buf` 的最近 `setjmp()` 调用发生在另一个线程中，或者不存在这样的调用，或者包含 `setjmp()` 调用的函数在此期间已经终止执行，或者 `setjmp()` 调用在具有可变修改类型的标识符作用域内，而执行在此期间已经离开该作用域，则行为是未定义的。`longjmp()` 是否恢复信号掩码、保持信号掩码不变，或者将其恢复到 `setjmp()` 调用时的值是未指定的。

所有可访问对象都具有值，抽象机的所有其他组件都处于状态（例如，浮点状态标志和打开的文件），这些值和状态都是 `longjmp()` 被调用时的状态，除非满足以下所有条件的自动存储期限对象的值是未指定的：

- 它们是包含相应 `setjmp()` 调用的函数的局部变量。
- 它们不具有 volatile 限定类型。
- 它们在 `setjmp()` 调用和 `longjmp()` 调用之间被修改。

虽然 `longjmp()` 是一个异步信号安全函数，如果它从信号处理程序中被调用，而该信号处理程序中断了一个非异步信号安全函数或等效函数（如在从 `main()` 的初始调用返回后执行的相当于 `exit()` 的处理），则任何后续对非异步信号安全函数或等效函数调用的行为是未定义的。

在调用线程中未执行 `jmp_buf` 结构初始化的情况下调用 `longjmp()` 的效果是未定义的。

## 返回值

`longjmp()` 完成后，线程执行应当继续，就像相应的 `setjmp()` 调用刚刚返回了由 `val` 指定的值一样。`longjmp()` 函数不应导致 `setjmp()` 返回 0；如果 `val` 为 0，`setjmp()` 应当返回 1。

## 错误

未定义错误。

## 应用程序用法

其行为依赖于信号掩码值的应用程序不应使用 `longjmp()` 和 `setjmp()`，因为它们对信号掩码的影响是未指定的，而应使用 `siglongjmp()` 和 `sigsetjmp()` 函数（这些函数可以在应用程序控制下保存和恢复信号掩码）。

建议应用程序不要从信号处理程序中调用 `longjmp()` 或 `siglongjmp()`。为了避免从信号处理程序中调用这些函数时的未定义行为，应用程序需要确保以下两件事之一：

1. 在调用 `longjmp()` 或 `siglongjmp()` 后，进程只调用异步信号安全函数，并且不从 `main()` 的初始调用返回。
2. 任何处理程序调用 `longjmp()` 或 `siglongjmp()` 的信号在每次对非异步信号安全函数的调用期间都被阻塞，并且在从 `main()` 的初始调用返回后不进行此类调用。

## 参见

- `setjmp()`
- `sigaction()`
- `siglongjmp()`
- `sigsetjmp()`
- `<setjmp.h>`

## 变更历史

### 首次发布于 Issue 1
派生自 SVID 的 Issue 1。

### Issue 5
描述已更新，以与 POSIX 线程扩展保持一致。

### Issue 6
超出 ISO C 标准的扩展被标记。

以下对 POSIX 实现的新要求来源于与单一 UNIX 规范的对齐：

- 描述现在明确地将 `longjmp()` 对信号掩码的影响设为未指定。

描述已更新，以与 ISO/IEC 9899:1999 标准保持一致。

### Issue 7
应用了 POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0365 [394]。

应用了 POSIX.1-2008, Technical Corrigendum 2, XSH/TC2-2008/0202 [516]。

### Issue 8
应用了 Austin Group Defect 1302，使此函数与 ISO/IEC 9899:2018 标准保持一致。

---
