# sigtimedwait, sigwaitinfo

## 名称

sigtimedwait, sigwaitinfo — 等待排队信号

## 概要

```c
#include <signal.h>

int sigtimedwait(const sigset_t *restrict set,
                 siginfo_t *restrict info,
                 const struct timespec *restrict timeout);

int sigwaitinfo(const sigset_t *restrict set,
                siginfo_t *restrict info);
```

## 描述

`sigtimedwait()` 函数应等价于 `sigwaitinfo()`，不同之处在于如果由 *set* 指定的信号都没有挂起，`sigtimedwait()` 应等待由 *timeout* 引用的 **timespec** 结构中指定的时间间隔。如果由 *timeout* 指向的 **timespec** 结构为零值且由 *set* 指定的信号都没有挂起，那么 `sigtimedwait()` 应立即返回并带有错误。如果 *timeout* 是空指针，则行为未指定。应使用 CLOCK_MONOTONIC 时钟来测量由 *timeout* 参数指定的时间间隔。

`sigwaitinfo()` 函数从由 *set* 指定的集合中选择挂起的信号。如果在 SIGRTMIN 到 SIGRTMAX 范围内的多个挂起信号中有任何一个被选中，它应该是编号最小的那个。实时信号和非实时信号之间的选择顺序，或者多个挂起的非实时信号之间的选择顺序是未指定的。如果在调用时 *set* 中没有信号挂起，调用线程应被挂起，直到 *set* 中的一个或多个信号变为挂起或直到它被一个未阻塞的、已捕获的信号中断。

`sigwaitinfo()` 函数应等价于 `sigwait()` 函数，不同之处在于返回值和错误报告方法不同（参见返回值），并且如果 *info* 参数是非 NULL，选中的信号编号应存储在 *si_signo* 成员中，信号的原因应存储在 *si_code* 成员中。如果有任何值排队到选中的信号，第一个这样的排队值应被出队，并且如果 *info* 参数是非 NULL，该值应存储在 *info* 的 *si_value* 成员中。用于对信号进行排队的系统资源应被释放并返回给系统供其他用途。如果没有值排队，*si_value* 成员的内容是未定义的。如果没有进一步信号排队给选中的信号，该信号的挂起指示应被重置。

## 返回值

成功完成时（即，由 *set* 指定的信号之一是挂起的或已生成的），`sigwaitinfo()` 和 `sigtimedwait()` 应返回选中的信号编号。否则，函数应返回值 -1 并设置 *errno* 来指示错误。

## 错误

`sigtimedwait()` 函数应在以下情况失败：

- **[EAGAIN]**
  - 在指定的超时期限内没有生成由 *set* 指定的信号。

`sigtimedwait()` 和 `sigwaitinfo()` 函数可能在以下情况失败：

- **[EINTR]**
  - 等待被一个未阻塞的、已捕获的信号中断。是否此错误导致这些函数失败应在系统文档中说明。

`sigtimedwait()` 函数也可能在以下情况失败：

- **[EINVAL]**
  - *timeout* 参数指定的 *tv_nsec* 值小于零或大于或等于 1000 百万。

实现应该仅在 *set* 中没有信号挂起并且需要等待时才检查此错误。

## 应用用法

`sigtimedwait()` 函数超时并返回 [EAGAIN] 错误。应用程序开发者应注意，这与其他函数如 `pthread_cond_timedwait()` 返回 [ETIMEDOUT] 不一致。

请注意，为确保生成的信号被排队且传递给 `sigqueue()` 的信号值在 *si_value* 中可用，使用 `sigwaitinfo()` 或 `sigtimedwait()` 的应用程序需要为集合中的每个信号设置 SA_SIGINFO 标志（参见 *2.4 信号概念*）。这意味着将每个信号设置为由三参数信号捕获函数处理，即使处理程序永远不会被调用。在设置 SA_SIGINFO 标志的同时将信号处理程序设置为 SIG_DFL 是不可能的（可移植地），因为分配给 **struct sigaction** 的 *sa_handler* 成员而不是 *sa_sigaction* 成员会导致未定义行为，并且 SIG_DFL 不必与 *sa_sigaction* 赋值兼容。即使编译器接受将 SIG_DFL 赋值给 *sa_sigaction*，实现也不需要将此值视为特殊的——它可能只是被当作信号捕获函数的地址。

## 基本原理

现有在实时系统上的编程实践使用暂停等待选定事件集的能力，并内联处理发生的第一个事件，而不是在信号处理函数中。这允许应用程序以类似于状态机的事件驱动风格编写。这种编程风格对于大规模事务处理很有用，其中应用程序的整体吞吐量和清晰跟踪状态的能力比最小化单个事件处理的响应时间更重要。

可以从本 POSIX.1-2024 卷中定义的实时信号函数机制构造出一个信号等待宏函数。然而，这样的宏必须包括为所有要等待的信号定义的通用处理程序。如果信号等待函数由内核提供，则可以避免处理程序处理开销的很大一部分。因此，本 POSIX.1-2024 卷提供了两个信号等待函数——一个无限期等待，一个带超时——作为整体实时信号函数规范的一部分。

具有超时功能的函数规范允许编写一个应用程序，如果在设定的时间段内没有发生事件，可以中断等待。有人认为在等待之前设置定时器事件并在等待中识别定时器事件也会实现相同的功能，但性能水平较低。由于与用户级定时器事件规范相关联的性能下降，以及在等待完成有效事件后随后取消该定时器事件，以及与用户级方法相关联的处理潜在竞争条件的复杂性，包含了单独的函数。

请注意，`sigwaitinfo()` 函数的语义几乎与本 POSIX.1-2024 卷定义的 `sigwait()` 函数相同。唯一的区别是 `sigwaitinfo()` 在 *value* 参数中返回排队的信号值。返回排队值是必需的，以便应用程序可以区分排队到同一信号编号的多个事件。

维护这两个不同的函数是因为一些实现可能选择实现 POSIX 线程扩展函数而不实现排队信号扩展。但是请注意，如果 *value* 参数是 NULL，`sigwaitinfo()` 不返回排队值，因此 POSIX 线程扩展 `sigwait()` 函数可以在 `sigwaitinfo()` 上作为宏实现。

`sigtimedwait()` 函数从 `sigwaitinfo()` 函数中分离出来，以解决关于重载 *timeout* 指针以表示无限期等待（无超时）、定时等待和立即返回的担忧，以及关于与其他函数一致性的担忧，在这些函数中条件等待和定时等待是纯阻塞函数的独立函数。`sigtimedwait()` 的语义被指定为 `sigwaitinfo()` 可以用 *timeout* 的空指针作为宏实现。

`sigwait` 函数为线程提供了一种同步机制来等待异步生成的信号。一个重要问题是，当信号发送时，有多少在调用 `sigwait()` 函数等待信号的挂起线程应该从调用中返回。考虑了四种选择：

1. 对同一信号的多个同时调用 `sigwait` 函数返回错误。
2. 一个或多个线程返回。
3. 所有等待线程返回。
4. 恰好一个线程返回。

禁止对同一信号进行多次调用 `sigwait()` 被认为是过度限制的。"一个或多个"行为使符合规范的包实现容易，但代价是迫使 POSIX 线程客户端在应用程序代码中保护 against 多个同时调用 `sigwait()` 以实现可预测的行为。有人担心"所有等待线程"行为会导致"信号广播风暴"，通过在一般情况下复制信号来消耗过多的 CPU 资源。此外，无法提出有说服力的例子来说明传递给所有比传递给一个更简单或更强大。

因此，共识是应该恰好有一个在调用 `sigwait` 函数等待信号时挂起的线程在该信号发生时返回。这并不是一个繁重的限制，因为：

* 可以从单向等待构建多路信号等待。
* 信号应该只由应用程序级代码处理，因为库例程无法猜测应用程序想要对为整个进程生成的信号做什么。
* 因此应用程序可以安排单个线程等待任何给定信号，并在其到达时调用任何需要的例程。

在使用信号进行进程间通信的应用程序中，信号处理通常在一个地方完成。或者，如果信号被捕获以便可以进行进程清理，信号处理线程可以为应用程序的每个部分调用单独的进程清理例程。由于应用程序主线程启动了应用程序的每个部分，它处于正确的抽象级别来告诉应用程序的每个部分进行清理。

当然，存在一些编程风格，在多个线程中考虑等待单个信号是合乎逻辑的。可以构造一个简单的 `sigwait_multiple()` 例程来实现此目标。一个可能的实现是将每个 `sigwait_multiple()` 调用者注册为已表达对一组信号的兴趣。然后调用者在特定于线程的条件变量上等待。单个服务器线程在所有注册信号的并集上调用 `sigwait()` 函数。当 `sigwait()` 函数返回时，设置适当的状态并广播条件变量。新的 `sigwait_multiple()` 调用者可能导致挂起的 `sigwait()` 调用被取消并重新发出，以更新正在等待的信号集。

## 未来方向

无。

## 另见

*2.4 信号概念*, *2.8.1 实时信号*, `pause()`, `pthread_sigmask()`, `sigaction()`, `sigpending()`, `sigsuspend()`, `sigwait()`

XBD `<signal.h>`, `<time.h>`

## 变更历史

首次在 Issue 5 中发布。包含用于与 POSIX 实时扩展和 POSIX 线程扩展对齐。

### Issue 6

这些函数被标记为实时信号扩展选项的一部分。

应用了 Open Group Corrigendum U035/3。`sigwaitinfo()` 函数的概要已更正，使第二个参数为 **siginfo_t \*** 类型。

[ENOSYS] 错误条件已被移除，因为如果实现不支持实时信号扩展选项，则不需要提供存根。

描述已更新以与 IEEE Std 1003.1j-2000 对齐，指定如果支持，则使用 CLOCK_MONOTONIC 时钟来测量超时间隔。

**restrict** 关键字已添加到 `sigtimedwait()` 和 `sigwaitinfo()` 原型中，以与 ISO/IEC 9899:1999 标准对齐。

应用了 IEEE Std 1003.1-2001/Cor 2-2004，项目 XSH/TC2/D6/130，将返回值部分中的措辞恢复到原始基础文档中的措辞（"实现应该仅在 *set* 中没有信号挂起并且需要等待时才检查此错误"）。

### Issue 7

`sigtimedwait()` 和 `sigwaitinfo()` 函数已从实时信号扩展选项移动到基本标准。

应用了 POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0583 [392]。

应用了 POSIX.1-2008, Technical Corrigendum 2, XSH/TC2-2008/0333 [815]。

### Issue 8

应用了 Austin Group Defect 1346，要求支持单调时钟。