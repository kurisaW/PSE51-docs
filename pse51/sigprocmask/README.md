# sigprocmask

## SYNOPSIS

```c
#include <signal.h>

int pthread_sigmask(int how, const sigset_t *restrict set,
                   sigset_t *restrict oset);
int sigprocmask(int how, const sigset_t *restrict set,
                sigset_t *restrict oset);
```

## DESCRIPTION

The `pthread_sigmask()` function shall examine or change (or both) the calling thread's signal mask.

If the argument `set` is not a null pointer, it points to a set of signals to be used to change the currently blocked set.

The argument `how` indicates the way in which the set is changed, and the application shall ensure it consists of one of the following values:

**SIG_BLOCK**
The resulting set shall be the union of the current set and the signal set pointed to by `set`.

**SIG_SETMASK**
The resulting set shall be the signal set pointed to by `set`.

**SIG_UNBLOCK**
The resulting set shall be the intersection of the current set and the complement of the signal set pointed to by `set`.

If the argument `oset` is not a null pointer, the previous mask shall be stored in the location pointed to by `oset`. If `set` is a null pointer, the value of the argument `how` is not significant and the thread's signal mask shall be unchanged; thus the call can be used to enquire about currently blocked signals.

If the argument `set` is not a null pointer, after `pthread_sigmask()` changes the currently blocked set of signals it shall determine whether there are any pending unblocked signals; if there are any, then at least one of those signals shall be delivered before the call to `pthread_sigmask()` returns.

It is not possible to block those signals which cannot be ignored. This shall be enforced by the system without causing an error to be indicated.

If any of the SIGFPE, SIGILL, SIGSEGV, or SIGBUS signals are generated while they are blocked, the result is undefined, unless the signal was generated by the action of another process, or by one of the functions `kill()`, `pthread_kill()`, `raise()`, or `sigqueue()`.

If `pthread_sigmask()` fails, the thread's signal mask shall not be changed.

The `sigprocmask()` function shall be equivalent to `pthread_sigmask()`, except that its behavior is unspecified if called from a multi-threaded process, and on error it returns -1 and sets `errno` to the error number instead of returning the error number directly.

## RETURN VALUE

Upon successful completion, `pthread_sigmask()` shall return 0; otherwise, it shall return the corresponding error number.

Upon successful completion, `sigprocmask()` shall return 0; otherwise, -1 shall be returned and `errno` shall be set to indicate the error.

## ERRORS

These functions shall fail if:

**[EINVAL]**
The `set` argument is not a null pointer and the value of the `how` argument is not equal to one of the defined values.

These functions shall not return an error code of [EINTR].

## EXAMPLES

### Signaling in a Multi-Threaded Process

This example shows the use of `pthread_sigmask()` in order to deal with signals in a multi-threaded process. It provides a fairly general framework that could be easily adapted/extended.

```c
#include <stdio.h>
#include <stdlib.h>
#include <pthread.h>
#include <signal.h>
#include <string.h>
#include <errno.h>
...

static sigset_t   signal_mask;  /* signals to block         */

int main (int argc, char *argv[])
{
    pthread_t  sig_thr_id;      /* signal handler thread ID */
    int        rc;              /* return code              */

    sigemptyset (&signal_mask);
    sigaddset (&signal_mask, SIGINT);
    sigaddset (&signal_mask, SIGTERM);
    rc = pthread_sigmask (SIG_BLOCK, &signal_mask, NULL);
    if (rc != 0) {
        /* handle error */
        ...
    }
    /* any newly created threads inherit the signal mask */

    rc = pthread_create (&sig_thr_id, NULL, signal_thread, NULL);
    if (rc != 0) {
        /* handle error */
        ...
    }

    /* APPLICATION CODE */
    ...
}

void *signal_thread (void *arg)
{
    int       sig_caught;    /* signal caught       */
    int       rc;            /* returned code       */

    rc = sigwait (&signal_mask, &sig_caught);
    if (rc != 0) {
        /* handle error */
    }
    switch (sig_caught)
    {
    case SIGINT:     /* process SIGINT  */
        ...
        break;
    case SIGTERM:    /* process SIGTERM */
        ...
        break;
    default:         /* should normally not happen */
        fprintf (stderr, "\nUnexpected signal %d\n", sig_caught);
        break;
    }
}
```

## APPLICATION USAGE

Although `pthread_sigmask()` has to deliver at least one of any pending unblocked signals that exist after it has changed the currently blocked set of signals, there is no requirement that the delivered signal(s) include any that were unblocked by the change. If one or more signals that were already unblocked become pending (see [2.4.1 Signal Generation and Delivery](https://pubs.opengroup.org/onlinepubs/9799919799/functions/V2_chap02.html#tag_16_04_01)) during the period the `pthread_sigmask()` call is executing, the signal(s) delivered before the call returns might include only those signals.

## RATIONALE

When a thread's signal mask is changed in a signal-catching function that is installed by `sigaction()`, the restoration of the signal mask on return from the signal-catching function overrides that change (see `sigaction()`). If the signal-catching function was installed with `signal()`, it is unspecified whether this occurs.

See `kill()` for a discussion of the requirement on delivery of signals.

## FUTURE DIRECTIONS

None.

## SEE ALSO

[`exec`](https://pubs.opengroup.org/onlinepubs/9799919799/functions/exec.html), [`kill()`](https://pubs.opengroup.org/onlinepubs/9799919799/functions/kill.html), [`sigaction()`](https://pubs.opengroup.org/onlinepubs/9799919799/functions/sigaction.html), [`sigaddset()`](https://pubs.opengroup.org/onlinepubs/9799919799/functions/sigaddset.html), [`sigdelset()`](https://pubs.opengroup.org/onlinepubs/9799919799/functions/sigdelset.html), [`sigemptyset()`](https://pubs.opengroup.org/onlinepubs/9799919799/functions/sigemptyset.html), [`sigfillset()`](https://pubs.opengroup.org/onlinepubs/9799919799/functions/sigfillset.html), [`sigismember()`](https://pubs.opengroup.org/onlinepubs/9799919799/functions/sigismember.html), [`sigpending()`](https://pubs.opengroup.org/onlinepubs/9799919799/functions/sigpending.html), [`sigqueue()`](https://pubs.opengroup.org/onlinepubs/9799919799/functions/sigqueue.html), [`sigsuspend()`](https://pubs.opengroup.org/onlinepubs/9799919799/functions/sigsuspend.html)

XBD [`<signal.h>`](https://pubs.opengroup.org/onlinepubs/9799919799/basedefs/signal.h.html)

## CHANGE HISTORY

First released in Issue 3. Included for alignment with the POSIX.1-1988 standard.

### Issue 5

The DESCRIPTION is updated for alignment with the POSIX Threads Extension.

The `pthread_sigmask()` function is added for alignment with the POSIX Threads Extension.

### Issue 6

The `pthread_sigmask()` function is marked as part of the Threads option.

The SYNOPSIS for `sigprocmask()` is marked as a CX extension to note that the presence of this function in the `<signal.h>` header is an extension to the ISO C standard.

The following changes are made for alignment with the ISO POSIX-1:1996 standard:

*   The DESCRIPTION is updated to explicitly state the functions which may generate the signal.

The normative text is updated to avoid use of the term "must" for application requirements.

The `restrict` keyword is added to the `pthread_sigmask()` and `sigprocmask()` prototypes for alignment with the ISO/IEC 9899:1999 standard.

IEEE Std 1003.1-2001/Cor 2-2004, item XSH/TC2/D6/105 is applied, updating "process' signal mask" to "thread's signal mask" in the DESCRIPTION and RATIONALE sections.

IEEE Std 1003.1-2001/Cor 2-2004, item XSH/TC2/D6/106 is applied, adding the example to the EXAMPLES section.

### Issue 7

The `pthread_sigmask()` function is moved from the Threads option to the Base.

POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0467 [319] is applied.

### Issue 8

Austin Group Defect 1132 is applied, clarifying the [EINVAL] error.

Austin Group Defect 1636 is applied, clarifying the exceptions to the equivalence of `pthread_sigmask()` and `sigprocmask()`.

Austin Group Defect 1731 is applied, clarifying that although `pthread_sigmask()` has to deliver at least one of any pending unblocked signals that exist after it has changed the currently blocked set of signals, there is no requirement that the delivered signal(s) include any that were unblocked by the change.

---

*UNIX® is a registered Trademark of The Open Group.*
*POSIX™ is a Trademark of The IEEE.*
*Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved*