# fopen — 打开流

## 概要

```c
#include <stdio.h>

FILE *fopen(const char *restrict pathname, const char *restrict mode);
```

## 描述

除了"独占访问"要求（见下文）外，此参考页描述的功能与 ISO C 标准一致。此处描述的要求与 ISO C 标准之间的任何其他冲突都是无意的。本 POSIX.1-2024 卷在涉及"独占访问"方面之外，所有 `fopen()` 功能均遵循 ISO C 标准。

`fopen()` 函数应打开路径名为 `pathname` 指向的字符串所指定的文件，并将一个流与之关联。

`mode` 参数指向一个字符串。如果字符串中的任何字符出现多次，则行为未指定。如果字符串以以下字符之一开头，则文件应以指示的模式打开。否则，行为未定义。

- **'r'**: 打开文件用于读取。
- **'w'**: 截断为零长度或创建文件用于写入。
- **'a'**: 追加；在文件末尾打开或创建文件用于写入。

字符串的其余部分可以包含以下任意字符，以任意顺序，并进一步影响文件的打开方式：

- **'b'**: 此字符应无效，但允许符合 ISO C 标准。
- **'e'**: 底层文件描述符应原子地设置 FD_CLOEXEC 标志。
- **'x'**: 如果 `mode` 的第一个字符是 'w' 或 'a'，则如果文件已存在或无法创建，函数应失败；如果文件不存在且可以创建，则应在底层文件系统支持的情况下，以实现定义的独占（也称为非共享）访问形式创建文件，前提是生成的文件权限与不使用 'x' 修饰符时的权限相同。如果 mode 的第一个字符是 'r'，则效果是实现定义的。

**注意：**

ISO C 标准要求独占访问"在底层文件系统支持独占访问的范围内"，但没有定义这意味着什么。按字面理解——系统必须在文件系统级别尽其所能来排除他人的访问——这将要求 POSIX.1 系统以防止其他用户和组访问的方式设置文件权限。因此，本 POSIX.1-2024 卷在"独占访问"要求方面不遵循 ISO C 标准。

- **'+'**: 文件应打开用于更新（读取和写入），而不仅仅是读取或写入。

以读取模式打开文件（`mode` 参数中的第一个字符为 'r'）应失败，如果文件不存在或无法读取。

以追加模式打开文件（`mode` 参数中的第一个字符为 'a'）应导致所有后续对文件的写入都被强制到当前文件末尾，无论中间是否有 `fseek()` 调用。

当以更新模式打开文件（`mode` 参数中包含 '+'）时，可以在关联的流上执行输入和输出操作。但是，应用程序应确保输出之后不直接跟随输入，除非有中间的 `fflush()` 调用或文件定位函数（`fseek()`、`fsetpos()` 或 `rewind()`），并且输入之后不直接跟随输出，除非有中间的文件定位函数调用，除非输入操作遇到文件末尾。

打开时，当且仅当可以确定流不引用交互设备时，流才是完全缓冲的。流的错误和文件结束指示器应被清除。

如果 `mode` 中的第一个字符是 'w' 或 'a' 且文件先前不存在，则在成功完成时，`fopen()` 应标记更新文件的最后数据访问、最后数据修改和最后文件状态更改时间戳，以及父目录的最后文件状态更改和最后数据修改时间戳。

如果 `mode` 中的第一个字符是 'w' 或 'a' 且文件先前不存在，`fopen()` 函数应创建文件，就像它调用了 `open()` 函数，其中 path 参数从 `pathname` 解释，oflag 参数值如下指定，第三个参数值为 S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP | S_IROTH | S_IWOTH。

如果 `mode` 中的第一个字符是 'w' 且文件先前存在，则在成功完成时，`fopen()` 应标记更新文件的最后数据修改和最后文件状态更改时间戳。

成功调用 `fopen()` 函数后，流的定向应被清除，编码规则应被清除，关联的 mbstate_t 对象应被设置为描述初始转换状态。

与打开的流关联的文件描述符应分配并打开，就像通过使用以下标志调用 `open()` 一样：

| fopen() 模式第一个字符 | fopen() 模式包含 '+' | 初始 open() 标志 |
|----------------------|---------------------|-----------------|
| 'r'                  | 否                   | O_RDONLY        |
| 'w'                  | 否                   | O_WRONLY|O_CREAT|O_TRUNC |
| 'a'                  | 否                   | O_WRONLY|O_CREAT|O_APPEND |
| 'r'                  | 是                   | O_RDWR          |
| 'w'                  | 是                   | O_RDWR|O_CREAT|O_TRUNC |
| 'a'                  | 是                   | O_RDWR|O_CREAT|O_APPEND |

当且仅当指定了 'e' 模式字符串字符时，O_CLOEXEC 标志应与上述表中指定的初始 `open()` 标志进行 OR 运算。

当且仅当 'x' 模式字符串字符与 'w' 或 'a' 一起指定时，O_EXCL 标志应与上述表中指定的初始 `open()` 标志进行 OR 运算。

如果 mode 包含 'x' 且底层文件系统支持通过使用实现特定的 `open()` 标志启用独占访问（见上文），则行为应如同也包含了这些标志。

当使用本标准指定的模式字符串时，实现应表现为没有其他标志传递给 `open()`。

## 返回值

成功完成时，`fopen()` 应返回指向控制流的对象的指针。否则，应返回空指针，并设置 errno 以指示错误。

## 错误

`fopen()` 函数应在以下情况下失败：

- **[EACCES]**: 路径前缀的某个组件的搜索权限被拒绝，或文件存在且 mode 指定的权限被拒绝，或文件不存在且要创建文件的父目录的写权限被拒绝。
- **[EEXIST]**: mode 参数以 w 或 a 开头且包含 x，但文件已存在。
- **[EILSEQ]**: mode 参数以 w 或 a 开头，文件先前不存在，且最后一个路径名组件不是可移植文件名且无法在目标目录中创建。
- **[EINTR]**: 在 `fopen()` 期间捕获了信号。
- **[EISDIR]**: 命名文件是目录且 mode 要求写访问。
- **[ELOOP]**: 在解析路径名参数过程中遇到符号链接循环。
- **[EMFILE]**: 进程可用的所有文件描述符当前都已打开。
- **[EMFILE]**: {STREAM_MAX} 流在调用进程中当前已打开。
- **[ENAMETOOLONG]**: 路径名的长度超过 {PATH_MAX}，或符号链接的路径名解析产生的中间结果长度超过 {PATH_MAX}。
- **[ENFILE]**: 系统中当前打开的文件数已达到最大允许数量。
- **[ENOENT]**: mode 字符串以 'r' 开头且路径名的某个组件不命名现有文件，或 mode 以 'w' 或 'a' 开头且路径名的路径前缀的某个组件不命名现有文件，或路径名为空字符串。
- **[ENOENT] 或 [ENOTDIR]**: 路径名参数包含至少一个非\<slash> 字符并以一个或多个尾随 \<slash> 字符结尾。如果去掉尾随 \<slash> 字符的路径名会命名现有文件，则不应发生 [ENOENT] 错误。
- **[ENOSPC]**: 将包含新文件的目录或文件系统无法扩展，文件不存在，且文件将要被创建。
- **[ENOTDIR]**: 路径前缀的某个组件命名既不是目录也不是指向目录的符号链接的现有文件，或路径名参数包含至少一个非\<slash> 字符并以一个或多个尾随 \<slash> 字符结尾且最后一个路径名组件命名既不是目录也不是指向目录的符号链接的现有文件。
- **[ENXIO]**: 命名文件是字符特殊文件或块特殊文件，与此特殊文件关联的设备不存在。
- **[EOVERFLOW]**: 命名文件是常规文件且文件大小无法在 off_t 类型的对象中正确表示。
- **[EROFS]**: 命名文件驻留在只读文件系统上且 mode 要求写访问。

`fopen()` 函数可能在以下情况下失败：

- **[EINVAL]**: mode 参数的值无效。
- **[ELOOP]**: 在解析路径名参数过程中遇到超过 {SYMLOOP_MAX} 个符号链接。
- **[EMFILE]**: {FOPEN_MAX} 流在调用进程中当前已打开。
- **[ENAMETOOLONG]**: 路径名的某个组件长度超过 {NAME_MAX}。
- **[ENOMEM]**: 可用存储空间不足。
- **[ETXTBSY]**: 文件是正在执行的纯过程（共享文本）文件且 mode 要求写访问。

## 示例

### 打开文件

以下示例尝试打开名为 file 的文件进行读取。`fopen()` 函数返回一个文件指针，用于后续的 `fgets()` 和 `fclose()` 调用。如果程序无法打开文件，它只会忽略它。

```c
#include <stdio.h>
...
FILE *fp;
...
void rgrep(const char *file)
{
...
    if ((fp = fopen(file, "r")) == NULL)
        return;
...
}
```

## 应用程序用法

如果应用程序需要以文件已存在时失败的方式创建文件，并且要么不需要文件的独占访问，要么不需要独占访问，它应该使用带有 O_CREAT 和 O_EXCL 标志的 `open()`，而不是使用 mode 中带有 'x' 的 `fopen()`。然后，如果需要，可以通过在 `open()` 返回的文件描述符上调用 `fdopen()` 来创建流。

## 原理

'e' 模式字符的提供是为了避免多线程应用程序中的数据竞争。没有它，文件描述符会在一个线程创建文件描述符的窗口和另一个线程使用 `fileno()` 和 `fcntl()` 设置 FD_CLOEXEC 标志之间泄漏到子进程中。也可以通过使用带有 O_CLOEXEC 的 `open()` 然后 `fdopen()` 来避免竞争，但是，`freopen()` 函数没有安全的替代方案，并且一致性要求 'e' 修饰符应该为所有接受模式字符串的函数标准化。

ISO C 标准只识别模式字符串中特定位置的 '+'、'b' 和 'x' 字符，将其他安排保留为未指定，并且只允许 'x' 在以 'w' 开头的模式字符串中。本标准特别要求支持模式字符串中除第一个字符外的所有字符以任何顺序识别。因此，"wxe" 和 "wex" 行为相同，虽然 "wx+" 在 ISO C 标准中未指定，但本标准要求它与 "w+x" 具有相同的行为。本标准还要求 'x' 适用于以 'a' 开头的模式字符串，以及对于以 'r' 开头的模式字符串具有实现定义的行为。因此，虽然 `open()` 在指定 O_EXCL 而不指定 O_CREAT 时具有未定义行为，但 `fopen()` 并非如此。

当 'x' 在 mode 中时，ISO C 标准要求文件在底层系统支持独占访问的范围内以独占访问创建。虽然 POSIX.1 没有指定启用独占访问的任何方法，但它允许存在实现特定的标志或标志来启用它。请注意，如果正在创建文件，它们应该是文件创建标志，而不是文件访问模式标志（即包含在 O_ACCMODE 中的标志）或文件状态标志，这样它们就不会影响 `fcntl()` 使用 F_GETFL 返回的值。在具有此类标志的实现上，如果对它们的支持依赖于文件系统，并且在 `fopen()` 用于在不支持它的文件系统上创建文件时请求独占访问，则如果这些标志会导致 `fopen()` 失败，则不得使用它们。

一些实现支持强制性文件锁定作为启用文件独占访问的手段。锁以正常方式设置，但它们不仅防止其他人设置冲突锁，还防止其他人以与锁冲突的方式访问文件的锁定部分的内容。但是，除非实现在文件创建时有一种设置整个文件写锁的方法，否则这不能满足 ISO C 标准中文件"在底层系统支持独占访问的范围内以独占访问创建"的要求。（让 `fopen()` 创建文件并在文件上设置锁作为两个独立的操作是不同的，并且它会引入竞争条件，即另一个进程可以在两个操作之间打开文件并写入它（或设置锁）。）然而，在所有支持强制性文件锁定的实现上，不鼓励使用它；因此，建议支持强制性文件锁定的实现不要添加创建具有整个文件独占锁的文件的方法，这样 `fopen()` 就不需要启用强制性文件锁定以符合 ISO C 标准。具有创建具有整个文件独占锁的文件方法的实现需要提供一种根据调用进程是在 POSIX.1 符合环境还是 ISO C 符合环境中执行来改变 `fopen()` 行为的方法。

模式 "rx" 的典型实现定义行为是忽略 'x'，但标准开发者不希望强制要求这种行为。例如，实现可以允许共享访问进行读取；即，不允许以这种方式打开的文件也被打开进行写入。

鼓励实现在 mode 以 'w' 或 'a' 开头、文件先前不存在且路径名的最后一个组件包含任何具有 \<newline> 字符编码值的字节时，让 `fopen()` 和 `freopen()` 报告 [EILSEQ] 错误。

## 未来方向

无。

## 另请参阅

- **2.5 标准 I/O 流**
- `creat()`
- `fclose()`
- `fdopen()`
- `fmemopen()`
- `freopen()`
- `open_memstream()`
- **<stdio.h>**

## 更改历史

首次在 Issue 1 中发布。源自 SVID 的 Issue 1。

### Issue 5

添加了大文件峰会扩展。

### Issue 6

超出 ISO C 标准的扩展被标记。

以下对 POSIX 实现的新要求源于与单一 UNIX 规范的对齐：

- 在 DESCRIPTION 中，添加了文本以指示在打开文件描述中设置偏移量最大值。此更改是为了支持大文件。
- 在 ERRORS 部分，添加了 [EOVERFLOW] 条件。此更改是为了支持大文件。
- 添加了 [ELOOP] 强制错误条件。
- 添加了 [EINVAL]、[EMFILE]、[ENAMETOOLONG]、[ENOMEM] 和 [ETXTBSY] 可选错误条件。

规范性文本已更新，以避免对应用程序要求使用"必须"一词。

为与 ISO/IEC 9899:1999 标准对齐进行以下更改：

- `fopen()` 的原型已更新。
- DESCRIPTION 已更新，以注意如果参数 mode 指向的字符串不是列出的那些，则行为未定义。

强制性 [ELOOP] 错误条件的措辞已更新，并添加了第二个可选 [ELOOP] 错误条件。

### Issue 7

应用 Austin Group Interpretation 1003.1-2001 #025，澄清文件创建模式。

应用 Austin Group Interpretation 1003.1-2001 #143。

应用 Austin Group Interpretation 1003.1-2001 #159，澄清在打开文件描述上设置的标志要求。

应用 SD5-XBD-ERN-4，更改 [EMFILE] 错误的定义。

应用 SD5-XSH-ERN-149，将 {STREAM_MAX} [EMFILE] 错误条件从"可能失败"更改为"应失败。

进行了与支持细粒度时间戳相关的更改。

应用 POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0156 [291,433]、XSH/TC1-2008/0157 [146,433]、XSH/TC1-2008/0158 [324] 和 XSH/TC1-2008/0159 [14]。

应用 POSIX.1-2008, Technical Corrigendum 2, XSH/TC2-2008/0122 [822]。

### Issue 8

应用 Austin Group Defect 251，鼓励实现禁止创建包含任何具有 \<newline> 字符编码值的字节的文件名。

应用 Austin Group Defect 293，添加 [EILSEQ] 错误。

应用 Austin Group Defects 411 和 1524，添加 'e' 和 'x' 模式字符串字符。

应用 Austin Group Defect 1200，更正 [ELOOP] 错误中的参数名称。

应用 Austin Group Defect 1302，使此函数与 ISO/IEC 9899:2018 标准对齐。

---
