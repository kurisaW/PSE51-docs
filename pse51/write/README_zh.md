# write

## 概要

```c
#include <unistd.h>

ssize_t pwrite(int fildes, const void *buf, size_t nbyte, off_t offset);
ssize_t write(int fildes, const void *buf, size_t nbyte);
```

## 描述

`write()` 函数应尝试从 `buf` 指向的缓冲区中写入 `nbyte` 个字节到与打开的文件描述符 `fildes` 关联的文件中。

在执行以下任何操作之前，如果 `nbyte` 为零且文件是常规文件，`write()` 函数可以检测并返回如下所述的错误。在没有错误的情况下，或者如果未执行错误检测，`write()` 函数应返回零且没有其他结果。如果 `nbyte` 为零且文件不是常规文件，则结果未指定。

在常规文件或其他支持定位的文件上，数据的实际写入应从与 `fildes` 关联的文件偏移量所指示的文件位���开始。在 `write()` 成功返回之前，文件偏移量应增加实际写入的字节数。对于常规文件，如果最后写入字节的位置大于或等于文件长度，则文件长度应设置为此位置加一。

在不支持定位的文件上，写入应始终从当前位置开始。与此类设备关联的文件偏移量的值未定义。

如果设置了文件状态标志的 O_APPEND 标志，文件偏移量应在每次写入之前设置到文件末尾，并且在更改文件偏移量和写入操作之间不应发生中间的文件修改操作。

如果 `write()` 请求写入的字节数超过可用空间（例如，进程的文件大小限制或介质的物理末尾），则只写入有空间的字节数。例如，假设在达到限制之前文件中还有 20 个字节的空间。写入 512 个字节将返回 20。下一次写入非零字节数将返回失败（除非如下所述）。

如果请求会导致文件大小超过进程的软文件大小限制，并且没有任何字节的空间可写，则请求应失败 [XSI]，实现应为线程生成 SIGXFSZ 信号。

如果在写入任何数据之前 `write()` 被信号中断，它应返回 -1 并将 `errno` 设置为 [EINTR]。

如果在成功写入一些数据后 `write()` 被信号中断，它应返回已写入的字节数。

如果 `nbyte` 的值大于 {SSIZE_MAX}，则结果由实现定义。

在向常规文件的 `write()` 成功返回之后：

* 从文件中被该写入修改的每个字节位置的任何成功 `read()` 都应返回该位置的 `write()` 指定的数据，直到这些字节位置再次被修改为止。
* 对文件中相同字节位置的任何后续成功 `write()` 都应覆盖该文件数据。

对管道或 FIFO 的写入请求应以与常规文件相同的方式处理，但有以下例外：

* 没有与管道或 FIFO 关联的文件偏移量，因此每个写入请求都应追加到管道或 FIFO 的末尾。
* {PIPE_BUF} 字节或更少的写入请求不应与���同一管道或 FIFO 上执行写操作的其他线程的数据交错。大于 {PIPE_BUF} 字节的写入可能会与其他线程的写操作在任意边界上交错数据，无论是否设置了文件状态标志的 O_NONBLOCK 标志。
* 如果 O_NONBLOCK 标志清除，写入请求可能导致线程阻塞，但在正常完成时应返回 `nbyte`。
* 如果设置了 O_NONBLOCK 标志，`write()` 请求应以以下不同方式处理：
    * `write()` 函数不应阻塞线程。
    * {PIPE_BUF} 或更少字节的写入请求应具有以下效果：如果管道或 FIFO 中有足够的可用空间，`write()` 应传输所有数据并返回请求的字节数。否则，`write()` 应不传输数据并返回 -1，将 `errno` 设置为 [EAGAIN]。
    * 超过 {PIPE_BUF} 字节的写入请求应导致以下之一：
        * 当至少可以写入一个字节时，传输它能传输的内容并返回写入的字节数。当之前写入管道或 FIFO 的所有数据都被读取时，它应传输至少 {PIPE_BUF} 字节。
        * 当无法写入任何数据时，不传输数据，并返回 -1，将 `errno` 设置为 [EAGAIN]。

当尝试写入支持非阻塞写入且无法立即接受数据的文件描述符（管道或 FIFO 除外）时：

* 如果 O_NONBLOCK 标志清除，`write()` 应阻塞调用线程，直到可以接受数据为止。
* 如果设置了 O_NONBLOCK 标志，`write()` 不应阻塞线程。如果不阻塞线程就可以写入一些数据，`write()` 应写入它能写入的内容并返回写入的字节数。否则，它应返回 -1 并将 `errno` 设置为 [EAGAIN]。

成功完成时，其中 `nbyte` 大于 0，`write()` 应标记文件的最后数据修改时间和最后文件状态更改时间以供更新，如果文件是常规文件，文件模式的 S_ISUID 和 S_ISGID 位可能被清除。

对于常规文件，不会发生超过在与 `fildes` 关联的打开文件描述中建立的偏移量最大值的数据传输。

如果 `fildes` 引用套接字，`write()` 应等效于没有设置任何标志的 `send()`。

[SIO] 如果设置了 O_DSYNC 位，文件描述符上的写入 I/O 操作应按照同步 I/O 数据完整性完成来定义的方式完成。

如果设置了 O_SYNC 位，文件描述符上的写入 I/O 操作应按照同步 I/O 文件完整性完成来定义的方式完成。

[SHM] 如果 `fildes` 引用共享内存对象，`write()` 函数的结果未指定。

[TYM] 如果 `fildes` 引用类型化内存对象，`write()` 函数的结果未指定。

`pwrite()` 函数应等效于 `write()`，只是它在给定位置写入且不更改文件偏移量（无论是否设置了 O_APPEND）。`pwrite()` 的前三个参数与 `write()` 相同，外加第四个参数 `offset` 表示文件内的所需位置。尝试在不支持定位的文件上执行 `pwrite()` 将导致错误。

## 返回值

成功完成时，这些函数应返回实际写入到与 `fildes` 关联的文件中的字节数。此数字不应大于 `nbyte`。否则，应返回 -1 并设置 `errno` 以指示错误。

## 错误

这些函数在以下情况下应失败：

**[EAGAIN]**
文件既不是管道，也不是 FIFO，也不是套接字，文件描述符设置了 O_NONBLOCK 标志，且线程在 `write()` 操作中会被延迟。

**[EBADF]**
`fildes` 参数不是用于写入的有效文件描述符。

**[EFBIG]**
尝试写入超过实现定义的最大文件大小的文件，并且没有任何字节的空间可写。

**[EFBIG]**
尝试写入超过进程文件大小限制的文件，并且没有任何字节的空间可写。[XSI] 还应为线程生成 SIGXFSZ 信号。

**[EFBIG]**
文件是常规文件，`nbyte` 大于 0，且起始位置大于或等于在与 `fildes` 关联的打开文件描述中建立的偏移量最大值。

**[EINTR]**
写操作由于接收到信号而终止，且没有数据传输。

**[EIO]**
进程是后台进程组的成员，尝试写入其控制终端，TOSTOP 已设置，调用线程没有阻塞 SIGTTOU，进程没有忽略 SIGTTOU，且进程的进程组是孤立的。此错误也可能在实现定义的条件下返回。

**[ENOSPC]**
包含文件的设备上没有剩余的可用空间。

`pwrite()` 函数在以下情况下应失败：

**[EINVAL]**
文件是常规文件或块特殊文件，且 `offset` 参数为负。文件偏移量应保持不变。

**[ESPIPE]**
文件不支持定位。

`write()` 函数在以下情况下应失败：

**[EAGAIN]**
文件是管道或 FIFO，文件描述符设置了 O_NONBLOCK 标志，且线程在写操作中会被延迟。

**[EAGAIN]** 或 **[EWOULDBLOCK]**
文件是套接字，文件描述符设置了 O_NONBLOCK 标志，且线程在写操作中会被延迟。

**[ECONNRESET]**
尝试在未连接的套接字上进行写入。

**[EPIPE]**
尝试写入没有任何进程打开用于读取的管道或 FIFO，或者只有一端打开的管道或 FIFO。还应向线程发送 SIGPIPE 信号。

**[EPIPE]**
尝试在已关闭写入或不再连接的套接字上进行写入。在后一种情况下，如果套接字是 SOCK_STREAM 类型，还应向线程发送 SIGPIPE 信号。

这些函数在以下情况下可能失败：

**[EIO]**
发生了物理 I/O 错误。

**[ENOBUFS]**
系统中没有足够的资源来执行操作。

**[ENXIO]**
对不存在的设备发出请求，或者请求超出了设备的能力。

`write()` 函数在以下情况下可能失败：

**[EACCES]**
尝试在套接字上进行写入，但调用进程没有适当的权限。

**[ENETDOWN]**
尝试在套接字上进行写入，但用于到达目的地的本地网络接口已关闭。

**[ENETUNREACH]**
尝试在套接字上进行写入，但没有到网络的路由。

---

*以下部分为信息性内容。*

## 示例

### 从缓冲区写入

以下示例将 `buf` 指向的缓冲区中的数据写入到与文件描述符 `fd` 关联的文件中。

```c
#include <sys/types.h>
#include <string.h>
...
char buf[20];
size_t nbytes;
ssize_t bytes_written;
int fd;
...
strcpy(buf, "This is a test\n");
nbytes = strlen(buf);

bytes_written = write(fd, buf, nbytes);
...
```

## 应用程序用法

无。

## 基本原理

另请参阅 `read()` 中的基本原理部分。

尝试写入管道或 FIFO 有几个主要特征：

* **原子性/非原子性**：如果在一个操作中写入的全部量不与任何其他线程的数据交错，则写入是原子的。当有多个写入者向单个读取者发送数据时，这很有用。应用程序需要知道预期可以原子执行的写请求的最大大小。这个最大值称为 {PIPE_BUF}。POSIX.1-2024 的这个版本没有说明大于 {PIPE_BUF} 字节的写请求是否是原子的，但要求 {PIPE_BUF} 或更少字节的写入应是原子的。

* **阻塞/立即**：只有在 O_NONBLOCK 清除时才可能阻塞。如果有足够的空间立即写入所有请求的数据，实现应该这样做。否则，调用线程可能阻塞；即暂停，直到有足够的空间可用于写入。管道或 FIFO 的有效大小（可以在一个操作中不阻塞写入的最大量）可能根据实现而动态变化，因此无法为其指定固定值。

* **完整/部分/延迟**：写请求：
    ```c
    int fildes;
    size_t nbyte;
    ssize_t ret;
    char *buf;

    ret = write(fildes, buf, nbyte);
    ```
    可能返回：

    **完整**
    `ret` = `nbyte`

    **部分**
    `ret` < `nbyte`

    如果 `nbyte` ≤ {PIPE_BUF}，这永远不会发生。如果确实发生（`nbyte` > {PIPE_BUF}），POSIX.1-2024 的这个版本不保证原子性，即使 `ret` ≤ {PIPE_BUF}，因为原子性是根据请求的量而不是写入的量来保证的。

    **延迟**
    `ret` = -1, `errno` = [EAGAIN]

    此错误表示稍后的请求可能成功。它不表示一定会成功，即使 `nbyte` ≤ {PIPE_BUF}，因为如果没有进程从管道或 FIFO 读取，写入永远不会成功。应用程序可以有用地计算 [EAGAIN] 由特定的 `nbyte` > {PIPE_BUF} 值引起的次数，并可能假设管道或 FIFO 的有效大小已减小，以后使用较小的值进行写入。

    部分写入和延迟写入只有在设置 O_NONBLOCK 时才可能。

这些属性的关系显示在下表中：

**向管道或 FIFO 写入，O_NONBLOCK 清除**

| 立即可写入： | 无 | 部分 | nbyte |
|---------------|----|-----|------|
| **nbyte** ≤ {PIPE_BUF} | 原子阻塞 nbyte | 原子阻塞 nbyte | 原子立即 nbyte |
| **nbyte** > {PIPE_BUF} | 阻塞 nbyte | 阻塞 nbyte | 阻塞 nbyte |

如果 O_NONBLOCK 标志清除，如果立即可写入的量小于请求的量，写请求应阻塞。如果标志被设置（通过 `fcntl()`），写请求绝不阻塞。

**向管道或 FIFO 写入，O_NONBLOCK 设置**

| 立即可写入： | 无 | 部分 | nbyte |
|---------------|----|-----|------|
| **nbyte** ≤ {PIPE_BUF} | -1, [EAGAIN] | -1, [EAGAIN] | 原子 nbyte |
| **nbyte** > {PIPE_BUF} | -1, [EAGAIN] | < nbyte 或 -1, [EAGAIN] | ≤ nbyte 或 -1, [EAGAIN] |

当设置 O_NONBLOCK 时，关于部分写入没有例外。除了写入空管道或 FIFO 之外，POSIX.1-2024 的这个版本没有确切指定何时执行部分写入，因为那将需要指定实现的内部细节。当设置 O_NONBLOCK 且请求量大于 {PIPE_BUF} 时，每个应用程序都应准备好处理部分写入，就像每个应用程序都应准备好处理其他类型文件描述符上的部分写入一样。

如果可以写入任何字节则强制至少写入一个字节的意图是为了保证如果管道或 FIFO 中有任何空间，每次写入都会取得进展。如果管道或 FIFO 为空，必须写入 {PIPE_BUF} 字节；如果不是，则必须取得一些进展。

在 POSIX.1-2024 的这个版本要求返回 -1 并将 `errno` 设置为 [EAGAIN] 的情况下，大多数历史实现返回零（设置 O_NDELAY 标志，这是 O_NONBLOCK 的历史前身，但本身不在此版本的 POSIX.1-2024 中）。POSIX.1-2024 的这个版本中的错误指示被选择为应用程序可以将这些情况与文件结束区分开来。虽然 `write()` 不能接收文件结束的指示，但 `read()` 可以，并且两个函数有相似的返回值。此外，一些现有系统（例如第八版）允许零字节写入表示读者应获得文件结束指示；对于那些系统，从 `write()` 返回零值表示成功写入了文件结束指示。

允许但不要求实现对零字节的 `write()` 请求执行错误检查。

考虑了 {PIPE_MAX} 限制的概念（指示可以在单个操作中写入管道或 FIFO 的最大字节数），但被拒绝，因为这个概念会不必要地限制应用程序写入。

另请参阅 `read()` 中关于 O_NONBLOCK 的讨论。

写入可以相对于其他读取和写入进行序列化。如果可以（通过任何方式）证明文件数据的 `read()` 发生在该数据的 `write()` 之后，它必须反映该 `write()`，即使调用是由不同线程进行的。类似的要求适用于对同一文件位置的多个写操作。这是保证数据从 `write()` 调用传播到后续 `read()` 调用所必需的。此要求对于网络文件系统特别重要，其中一些缓存方案违反了这些语义。

请注意，这是根据 `read()` 和 `write()` 指定的。XSI 扩展 `readv()` 和 `writev()` 也遵循这些语义。不遵循这些序列化要求的新"高性能"写入类似物也会被此措辞允许。POSIX.1-2024 的这个版本也没有说明应用程序级缓存（如 stdio 所做的）的任何影响。

POSIX.1-2024 的这个版本没有指定返回错误后的文件偏移量的值；情况太多了。对于编程错误，如 [EBADF]，这个概念没有意义，因为没有涉及文件。对于立即检测到的错误，如 [EAGAIN]，显然指针不应更改。然而，在中断或硬件错误之后，更新的值会非常有用，并且是许多实现的行为。

POSIX.1-2024 的这个版本没有指定从多个线程对常规文件的并发写入的行为，除了每次写入都是原子的（见 2.9.7 线程与文件操作的交互）。应用程序应使用某种形式的并发控制。

POSIX.1-2024 的这个版本有意不指定除 [ESPIPE] 之外的任何与管道、FIFO 和套接字相关的 `pwrite()` 错误。

## 未来方向

无。

## 另请参阅

`chmod()`, `creat()`, `dup()`, `fcntl()`, `getrlimit()`, `lseek()`, `open()`, `pipe()`, `read()`, `writev()`

XBD `<limits.h>`, `<sys/uio.h>`, `<unistd.h>`

## 更改历史

首次在 Issue 1 中发布。源自 SVID 的 Issue 1。

### Issue 5

为与 POSIX 实时扩展和 POSIX 线程扩展对齐，更新了描述。

添加了大文件峰会扩展。

添加了 `pwrite()` 函数。

### Issue 6

描述指出 `write()` 函数不阻塞线程。之前这说的是"进程"而不是"线程"。

为与 XSI STREAMS 选项组的一部分，在描述和错误部分更新了对 STREAMS 的引用。

从与单一 UNIX 规范对齐得出以下对 POSIX 实现的新要求：

* 描述现在指出如果 `write()` 在成功写入一些数据后被信号中断，它返回写入的字节数。在 POSIX.1-1988 标准中，`write()` 是返回写入的字节数还是返回 -1 并将 `errno` 设置为 [EINTR] 是可选的。这是 FIPS 要求。
* 为支持大文件进行了以下更改：
    * 对于常规文件，不会发生超过在与 `fildes` 关联的打开文件描述中建立的偏移量最大值的数据传输。
    * 添加了第二个 [EFBIG] 错误条件。
* 添加了 [EIO] 错误条件。
* 为管道只有一端打开的情况添加了 [EPIPE] 错误条件。
* 添加了 [ENXIO] 可选错误条件。

在描述中添加了关于套接字的文本。

为与 IEEE P1003.1a 草案标准对齐进行了以下更改：

* 澄清了零字节读取的效果。

通过指定 `write()` 对类型化内存对象的结果未指定，更新了描述以与 IEEE Std 1003.1j-2000 对齐。

为套接字上的操作添加了以下错误条件：[EAGAIN]、[EWOULDBLOCK]、[ECONNRESET]、[ENOTCONN] 和 [EPIPE]。

使 [EIO] 错误变为可选。

为套接字添加了 [ENOBUFS] 错误。

为套接字上的操作添加了以下错误条件：[EACCES]、[ENETDOWN] 和 [ENETUNREACH]。

`writev()` 函数被拆分到单独的参考页面。

应用 IEEE Std 1003.1-2001/Cor 2-2004，项目 XSH/TC2/D6/146，将错误部分中的文本从"向调用进程生成 SIGPIPE 信号"更新为"还应向线程发送 SIGPIPE 信号"。

应用 IEEE Std 1003.1-2001/Cor 2-2004，项目 XSH/TC2/D6/147，对基本原理进行了更正。

### Issue 7

`pwrite()` 函数从 XSI 选项移到基础部分。

与 XSI STREAMS 选项相关的功能被标记为过时。

应用 SD5-XSH-ERN-160，更新描述以澄清 `pwrite()` 函数的要求，并将"文件指针"的使用更改为"文件偏移量"。

应用 POSIX.1-2008，技术勘误 1，XSH/TC1-2008/0742 [219]、XSH/TC1-2008/0743 [215]、XSH/TC1-2008/0744 [79] 和 XSH/TC1-2008/0745 [215]。

应用 POSIX.1-2008，技术勘误 2，XSH/TC2-2008/0401 [676,710] 和 XSH/TC2-2008/0402 [966]。

### Issue 8

应用 Austin Group 缺陷 308，澄清 [EFBIG] 错误的处理。

应用 Austin Group 缺陷 1330，删除过时接口。

应用 Austin Group 缺陷 1430，澄清与管道和 FIFO 上数据交错相关的要求适用于其他线程中的写操作，而不仅仅是其他进程，并将一些"管道"的使用更改为"管道或 FIFO"。

应用 Austin Group 缺陷 1669，从与进程文件大小限制相关的 [EFBIG] 错误部分删除 XSI 着色。

---

*信息性文本结束。*

---

UNIX® 是 The Open Group 的注册商标。
POSIX™ 是 IEEE 的商标。
版权所有 © 2001-2024 The IEEE and The Open Group，保留所有权利