# pthread_exit — 线程终止

## 概要

```c
#include <pthread.h>

_Noreturn void pthread_exit(void *value_ptr);
```

## 描述

`pthread_exit()` 函数应当终止调用线程，并使 `value_ptr` 的值对任何与终止线程的成功连接操作可用。任何已推送但尚未弹出的取消清理处理程序应当按其被推送的相反顺序弹出并执行。在所有取消清理处理程序执行完毕后，如果线程有任何线程特定的数据（无论是与 `tss_t` 键类型还是 `pthread_key_t` 键类型相关联），应调用适当的析构函数，调用顺序未指定。线程终止不会释放任何应用程序可见的进程资源，包括但不限于互斥锁和文件描述符，也不会执行任何进程级别的清理操作，包括但不限于调用可能存在的任何 `atexit()` 例程。

当一个不是使用 `thrd_create()` 创建、也不是 `main()` 首次调用的线程从用于创建它的启动例程返回时，会隐式调用 `pthread_exit()`。函数的返回值将作为线程的退出状态。

如果从作为显式或隐式调用 `pthread_exit()` 结果而被调用的取消清理处理程序或析构函数中调用 `pthread_exit()`，其行为是未定义的。

线程终止后，访问线程的局部（自动）变量的结果是未定义的。因此，不应将退出线程的局部变量的引用用作 `pthread_exit()` 的 `value_ptr` 参数值。

在最后一个线程终止后，进程应以退出状态 0 退出。其行为应如同实现在线程终止时调用参数为零的 `_exit()`。

## 返回值

`pthread_exit()` 函数不能返回到其调用者。

## 错误

未定义任何错误。

## 示例

无。

## 应用程序用法

不应从使用 `thrd_create()` 创建的线程中调用 `pthread_exit()`，因为它们的退出状态具有不同的类型（`int` 而不是 `void *`）。如果从初始线程中调用 `pthread_exit()` 并且它不是最后一个终止的线程，其他线程不应尝试使用 `thrd_join()` 获取其退出状态。

## 基本原理

使用 `pthread_create()` 启动的线程终止的正常机制是从启动它的 `pthread_create()` 调用中指定的例程返回。`pthread_exit()` 函数提供了线程在不要求从其启动例程返回的情况下终止的能力，从而提供了一个类似于 `_exit()` 的函数。

无论线程终止的方法如何，任何已推送但尚未弹出的取消清理处理程序都会被执行，并且任何存在的线程特定数据的析构函数也会被执行。POSIX.1-2024 要求取消清理处理程序按顺序弹出和调用。在所有取消清理处理程序执行完毕后，对于线程中存在的每个线程特定数据项，会以未指定的顺序调用线程特定数据析构函数。这种排序是必要的，因为取消清理处理程序可能依赖于线程特定数据。

由于状态的意义由应用程序确定（除非线程已被取消，此时为 PTHREAD_CANCELED），实现不知道什么是非法的状态值，这就是为什么不进行地址错误检查的原因。

## 未来方向

无。

## 参见

- `_exit()`
- `pthread_create()`
- `pthread_join()`
- `pthread_key_create()`
- `thrd_create()`
- `thrd_exit()`
- `tss_create()`
- `<pthread.h>`

## 更改历史

首次在 Issue 5 中发布。包含用于与 POSIX 线程扩展对齐。

### Issue 6

`pthread_exit()` 函数被标记为 Threads 选项的一部分。

### Issue 7

`pthread_exit()` 函数从 Threads 选项移动到 Base。

### Issue 8

应用 Austin Group 缺陷 1302，在概要中添加了 `_Noreturn`，并更新页面以考虑 `<threads.h>` 接口的添加。