# strftime, strftime_l — 将日期和时间转换为字符串

## 概要

```c
#include <time.h>

size_t strftime(char *restrict s, size_t maxsize,
               const char *restrict format, const struct tm *restrict timeptr);

[CX] size_t strftime_l(char *restrict s, size_t maxsize,
                      const char *restrict format, const struct tm *restrict timeptr,
                      locale_t locale);
```

## 描述

对于 `strftime()`：[CX] 本参考页描述的功能与 ISO C 标准保持一致。此处描述的要求与 ISO C 标准之间的任何冲突都是非故意的。本卷 POSIX.1-2024 遵从 ISO C 标准。

`strftime()` 函数应按照 `format` 指向的字符串控制，将字节放入 `s` 指向的数组中。应用程序应确保格式是字符串，如果有移位状态，则应以其初始移位状态开始和结束。格式字符串由零个或多个转换规范和普通字符组成。

每个转换规范由 '%' 字符引入，其后按顺序出现以下内容：

*   [CX] 可选标志：
    *   `0` - 零字符（'0'），指定用作填充字符的是 '0'
    *   `+` - 加号字符（'+'），指定用作填充字符的是 '0'，并且当且仅当生成的字段占用超过四个字节来表示年份（对于 %F、%G 或 %Y）或超过两个字节来表示年份除以 100（对于 %C）时，如果正在处理的年份大于等于零则包含前导加号字符，如果年份小于零则包含前导连字符减号（'-'）。
    *   默认填充字符未指定。

*   可选的最小字段宽度。如果转换后的值（包括任何前导 '+' 或 '-' 符号）的字节数少于最小字段宽度且填充字符不是 NUL 字符，则输出应在左侧（在任何前导 '+' 或 '-' 符号之后）用填充字符填充。

*   可选的 E 或 O 修饰符。

*   终止转换说明符字符，指示要应用的转换类型。

[CX] 如果指定了多个标志字符、指定了标志字符但没有最小字段宽度、指定了最小字段宽度但没有标志字符、将修饰符与标志或最小字段宽度一起指定，或者为除 C、F、G 或 Y 之外的任何转换说明符指定了最小字段宽度，则结果未指定。

所有普通字符（包括终止的 NUL 字符）都原样复制到数组中。如果在重叠的对象之间进行复制，则行为未定义。数组中放置的字节数不超过 `maxsize`。每个转换说明符将被适当的字符替换，如下列表所述。适当的字符使用当前语言环境的 `LC_TIME` 类别和 `timeptr` 指向的分解时间结构的零个或多个成员的值确定，如描述中的括号所示。如果任何指定值超出正常范围，则存储的字符未指定。

[CX] `strftime_l()` 函数应等同于 `strftime()` 函数，除了使用的语言环境数据来自 `locale` 表示的语言环境。

本地时区信息应设置为如同 `strftime()` 调用了 `tzset()`。

### 转换说明符

应支持以下转换说明符：

**%a** - 替换为语言环境的缩写工作日名称。[`tm_wday`]

**%A** - 替换为语言环境的完整工作日名称。[`tm_wday`]

**%b** - 替换为语言环境的缩写月份名称。[`tm_mon`]

**%B** - 替换为语言环境的完整月份名称。[`tm_mon`]

**%c** - 替换为语言环境的适当日期和时间表示。

**%C** - 替换为年份除以 100 并截断为整数的十进制数。[`tm_year`]
-   如果未指定最小字段宽度：
    *   如果年份在 0 到 9999 之间（含边界值），应将两个字符放入 `s` 指向的数组中，如果本应只有一个数字则包含前导 '0'。
    *   [CX] 如果年份小于 0 或大于 9999，放入 `s` 指向的数组的字符数应为年份除以 100 并截断后的结果中的数字位数和前导符号字符（如果有），或两个，以较大者为准。

**%d** - 替换为月份中的日期，十进制数 [01,31]。[`tm_mday`]

**%D** - 等同于 %m/%d/%y。[`tm_mon`, `tm_mday`, `tm_year`]

**%e** - 替换为月份中的日期，十进制数 [1,31]；单个数字前面加空格。[`tm_mday`]

**%F** - 如果没有标志且没有指定最小字段宽度，则等同于 %Y-%m-%d。（对于 1000 到 9999 年之间的年份，这提供 ISO 8601:2019 标准的完整表示，扩展格式的特定日期表示。）[`tm_year`, `tm_mon`, `tm_mday`]

**%g** - 替换为基于周的年份的最后两位数字，十进制数 [00,99]。[`tm_year`, `tm_wday`, `tm_yday`]

**%G** - 替换为基于周的年份，十进制数（例如 1977）。[`tm_year`, `tm_wday`, `tm_yday`]

**%h** - 等同于 %b。[`tm_mon`]

**%H** - 替换为小时（24小时制），十进制数 [00,23]。[`tm_hour`]

**%I** - 替换为小时（12小时制），十进制数 [01,12]。[`tm_hour`]

**%j** - 替换为年份中的第几天，十进制数 [001,366]。[`tm_yday`]

**%m** - 替换为月份，十进制数 [01,12]。[`tm_mon`]

**%M** - 替换为分钟，十进制数 [00,59]。[`tm_min`]

**%n** - 替换为换行符。

**%p** - 替换为语言环境中 a.m. 或 p.m. 的等价形式。[`tm_hour`]

**%r** - 替换为12小时制表示法的时间；[CX] 如果语言环境中不支持12小时制格式，这应该是空字符串或24小时制表示法的时间。在POSIX语言环境中，这应等同于 %I:%M:%S %p。[`tm_hour`, `tm_min`, `tm_sec`]

**%R** - 替换为24小时制表示法的时间（%H:%M）。[`tm_hour`, `tm_min`]

**%s** - [CX] 替换为自纪元以来的秒数，十进制数，按 `mktime()` 描述的计算方式计算。[`tm_year`, `tm_mon`, `tm_mday`, `tm_hour`, `tm_min`, `tm_sec`, `tm_isdst`]

**%S** - 替换为秒，十进制数 [00,60]。[`tm_sec`]

**%t** - 替换为制表符。

**%T** - 替换为时间（%H:%M:%S）。[`tm_hour`, `tm_min`, `tm_sec`]

**%u** - 替换为工作日，十进制数 [1,7]，1 表示星期一。[`tm_wday`]

**%U** - 替换为年份中的周数，十进制数 [00,53]。一月的第一个星期日是第1周的第一天；新年中此日期之前的日期在第0周。[`tm_year`, `tm_wday`, `tm_yday`]

**%V** - 替换为年份中的周数（星期一为一周的第一天），十进制数 [01,53]。如果包含1月1日的那一周在新年中有四天或更多天，则它被认为是第1周。否则，它是上一年的最后一周，下一周是第1周。1月4日和1月的第一个星期四总是在第1周。[`tm_year`, `tm_wday`, `tm_yday`]

**%w** - 替换为工作日，十进制数 [0,6]，0 表示星期日。[`tm_wday`]

**%W** - 替换为年份中的周数，十进制数 [00,53]。一月的第一个星期一是第1周的第一天；新年中此日期之前的日期在第0周。[`tm_year`, `tm_wday`, `tm_yday`]

**%x** - 替换为语言环境的适当日期表示。

**%X** - 替换为语言环境的适当时间表示。

**%y** - 替换为年份的最后两位数字，十进制数 [00,99]。[`tm_year`]

**%Y** - 替换为年份，十进制数（例如1997）。[`tm_year`]

**%z** - 替换为与UTC的偏移量，ISO 8601:2019 标准格式（+hhmm 或 -hhmm），如果无法确定时区则不替换任何字符。例如，"-0430" 表示比UTC晚4小时30分钟（格林威治以西）。[CX] 如果 `tm_isdst` 为零，则使用标准时间偏移量。如果 `tm_isdst` 大于零，则使用夏令时偏移量。如果 `tm_isdst` 为负数，则不返回任何字符。[`tm_isdst`, [CX] `tm_gmtoff`]

**%Z** - 替换为时区名称或缩写，如果不存在时区信息则不替换任何字节。[`tm_isdst`, [CX] `tm_zone`]

**%%** - 替换为 %。

如果转换说明符与上述任何一个都不对应，则行为未定义。

[CX] 如果 `struct tm` 分解时间结构由 `localtime()` 或 `localtime_r()` 创建，或由 `mktime()` 修改，并且 `TZ` 的值随后被修改，则当 `strftime()` 使用这样的分解时间结构调用时，%Z 和 %z `strftime()` 转换说明符的结果未定义。

如果 `struct tm` 分解时间结构由 `gmtime()` 或 `gmtime_r()` 创建或修改，则当 `strftime()` 使用这样的分解时间结构调用时，%Z 和 %z 转换说明符的结果应指UTC还是当前本地时区未指定。

### 修改的转换说明符

某些转换说明符可以通过 E 或 O 修饰符字符修改，以指示应使用替代格式或规范，而不是未修改转换说明符通常使用的格式或规范。如果当前语言环境不存在替代格式或规范，则行为应等同于使用未修改的转换说明符。

**%Ec** - 替换为语言环境的替代适当日期和时间表示。

**%EC** - 替换为语言环境替代表示中的基准年份（周期）名称。

**%Ex** - 替换为语言环境的替代日期表示。

**%EX** - 替换为语言环境的替代时间表示。

**%Ey** - 替换为语言环境替代表示中与 %EC 的偏移量（仅年份）。

**%EY** - 替换为完整的替代年份表示。

**%Ob** - [CX] 替换为语言环境的缩写替代月份名称。

**%OB** - [CX] 替换为语言环境的适当替代完整月份名称。

**%Od** - 替换为月份中的日期，使用���言环境的替代数字符号，如果存在零的替代符号则根据需要用前导零填充；否则用前导空格字符填充。

**%Oe** - 替换为月份中的日期，使用语言环境的替代数字符号，根据需要用前导空格字符填充。

**%OH** - 使用语言环境的替代数字符号替换小时（24小时制）。

**%OI** - 使用语言环境的替代数字符号替换小时（12小时制）。

**%Om** - 使用语言环境的替代数字符号替换月份。

**%OM** - 使用语言环境的替代数字符号替换分钟。

**%OS** - 使用语言环境的替代数字符号替换秒。

**%Ou** - 使用语言环境的替代表示替换工作日为数字（星期一=1）。

**%OU** - 使用语言环境的替代数字符号替换年份中的周数（星期日为一周的第一天，规则对应%U）。

**%OV** - 使用语言环境的替代数字符号替换年份中的周数（星期一为一周的第一天，规则对应%V）。

**%Ow** - 使用语言环境的替代数字符号替换工作日编号（星期日=0）。

**%OW** - 使用语言环境的替代数字符号替换年份中的周数（星期一为一周的第一天）。

**%Oy** - 使用语言环境的替代数字符号替换年份（与 %C 的偏移量）。

%g、%G 和 %V 根据 ISO 8601:2019 标准的基于周的年份给出值。在此系统中，周从星期一开始，年份的第1周是包含1月4日的那一周，该周也是包含年份第一个星期四的那一周，也是年份中至少包含四天的第一周。如果1月的第一个星期一是2日、3日或4日，则前面的几天是前一年的最后一周的一部分；因此，对于1999年1月2日星期六，%G 被替换为1998，%V 被替换为53。如果12月29日、30日或31日是星期一，它和任何后续日期是下一年的第1周的一部分。因此，对于1997年12月30日星期二，%G 被替换为1998，%V 被替换为01。

[CX] 如果 `strftime_l()` 的 `locale` 参数是特殊语言环境对象 LC_GLOBAL_LOCALE 或不是有效的语言环境对象句柄，则行为未定义。

## 返回值

如果成功，这些函数应返回放入 `s` 指向数组的字节数，不包括终止的 NUL 字符。[CX] 如果成功，`errno` 不应更改。否则，应返回0，[CX] `errno` 应设置为指示错误，数组的内容未指定。

## 错误

[CX] 这些函数在以下情况下可能会失败：

- **[ERANGE]** - 结果的总字节数（包括终止的 NUL 字符）超过 `maxsize`。

这些函数在以下情况下可能会失败：

- **[EINVAL]** - `format` 字符串包含 %s 转换且自纪元以来的秒数为负数。
- **[EOVERFLOW]** - `format` 字符串包含 %s 转换且自纪元以来的秒数无法在 `time_t` 中表示。

## 示例

### 获取本地化日期字符串

以下示例首先将语言环境设置为用户的默认值。语言环境信息将在 `nl_langinfo()` 和 `strftime()` 函数中使用。`nl_langinfo()` 函数返回本地化的日期字符串，该字符串指定日期的布局方式。`strftime()` 函数使用此信息，并使用 `tm` 结构的值，将日期和时间信息放入 `datestring`。

```c
#include <time.h>
#include <locale.h>
#include <langinfo.h>
...
struct tm *tm;
char datestring[256];
...
setlocale (LC_ALL, "");
...
strftime (datestring, sizeof(datestring), nl_langinfo (D_T_FMT), tm);
```

## 应用程序用法

如果格式是空字符串或由转换规范（如 %p 或 %Z）组成，这些转换规范在当前语言环境中或由于 `tzname[]` 的当前设置而替换为无字符，则返回值 0 可能表示成功或失败。为了区分 `strftime()` 返回0时的成功和失败，应用程序可以在调用 `strftime()` 之前将 `errno` 设置为0，并测试之后的 `errno` 是否为0。

%S 的值范围是 [00,60] 而不是 [00,59]，以允许偶尔的闰秒。

某些转换说明符是其他说明符的重复。它们包含是为了与第2期发布的 `nl_cxtime()` 和 `nl_ascxtime()` 兼容。

`strftime()` 中的 %C、%F、%G 和 %Y 格式说明符总是打印完整值，但 `strptime()` %C、%F 和 %Y 格式说明符只扫描两位数字（假定为四位年份的前两位数字）对应 %C，和四位数字（假定为整个（四位）年份）对应 %F 和 %Y。这模仿了 `printf()` 和 `scanf()` 的行为。

在 C 或 POSIX 语言环境中，E 和 O 修饰符被忽略，以下说明符的替换字符串为：

- **%a** - %A 的前三个字符。
- **%A** - Sunday、Monday、...、Saturday 之一。
- **%b** - %B 的前三个字符。
- **%B** - January、February、...、December 之一。
- **%c** - 等同于 %a %b %e %T %Y。
- **%p** - AM 或 PM 之一。
- **%r** - 等同于 %I:%M:%S %p。
- **%x** - 等同于 %m/%d/%y。
- **%X** - 等同于 %T。
- **%Z** - 实现定义。

## 另请参阅

`asctime()`、`clock()`、`ctime()`、`difftime()`、`futimens()`、`getdate()`、`gmtime()`、`localtime()`、`mktime()`、`strptime()`、`time()`、`tzset()`、`uselocale()`

XBD 7.3.5 LC_TIME、`<time.h>`