# sprintf - 打印格式化输出

## SYNOPSIS

```c
#include <stdio.h>

int asprintf(char **restrict ptr, const char *restrict format, ...);
int dprintf(int fildes, const char *restrict format, ...);

int fprintf(FILE *restrict stream, const char *restrict format, ...);
int printf(const char *restrict format, ...);
int snprintf(char *restrict s, size_t n, const char *restrict format, ...);
int sprintf(char *restrict s, const char *restrict format, ...);
```

## DESCRIPTION

`fprintf()` 函数应将输出放置在指定的输出流 `stream` 上。`printf()` 函数应将输出放置在标准输出流 `stdout` 上。`sprintf()` 函数应将输出后跟空字节 '\0' 放置在从 s 开始的连续字节中；用户有责任确保有足够的空间可用。

`asprintf()` 函数应等价于 `sprintf()`，不同之处在于输出字符串应写入动态分配的内存，该内存通过调用 `malloc()` 分配，长度足够容纳结果字符串，包括终止空字节。如果对 `asprintf()` 的调用成功，则此动态分配字符串的地址应存储在由 `ptr` 引用的位置。

`dprintf()` 函数应等价于 `fprintf()` 函数，不同之处在于 `dprintf()` 应将输出写入与 `fildes` 参数指定的文件描述符关联的文件，而不是将输出放置在流上。

`snprintf()` 函数应等价于 `sprintf()`，增加了 `n` 参数，该参数限制写入到由 `s` 引用的缓冲区的字节数。如果 `n` 为零，则不应写入任何内容，且 `s` 可能为空指针。否则，超过第 `n-1` 个的输出字节将被丢弃而不是写入数组，并且在实际写入数组的字节末尾写入一个空字节。

如果由于调用 `sprintf()` 或 `snprintf()` 而在重叠的对象之间进行复制，则结果未定义。

这些函数中的每一个都在 `format` 的控制下转换、格式化并打印其参数。应用程序应确保格式是一个字符字符串，如果有，则以其初始移位状态开始和结束。格式由零个或多个指令组成：*普通字符*，这些字符简单地复制到输出流；和*转换说明*，每个转换说明应导致获取零个或多个参数。如果格式没有足够的参数，则结果未定义。如果格式已用尽而参数仍有剩余，则多余的参数应被求值但被忽略。

转换可以应用于参数列表中格式之后的第 n 个参数，而不是下一个未使用的参数。在这种情况下，转换说明符字符 %（见下文）被序列 "%n$" 替换，其中 n 是范围 [1,{NL_ARGMAX}] 中的十进制整数，给出参数在参数列表中的位置。此功能提供了定义格式字符串的功能，该字符串以适合特定语言的顺序选择参数（参见示例部分）。

格式可以包含编号参数转换说明（即，由 "%n$" 引入并可选地包含字段宽度和精度的 "*m$" 形式），或未编号参数转换说明（即，由 % 字符引入并可选地包含字段宽度和精度的 * 形式），但不能同时包含两者。唯一的例外是 %% 可以与 "%n$" 形式混合。在格式字符串中混合编号和未编号参数说明的结果是未定义的。当使用编号参数说明时，指定第 N 个参数需要所有前导参数（从第一个到第 (N-1) 个）都在格式字符串中指定。

在包含 "%n$" 形式转换说明的格式字符串中，参数列表中的编号参数可以从格式字符串中按需引用多次。

在包含 % 形式转换说明的格式字符串中，每个转换说明使用参数列表中的第一个未使用参数。

所有形式的 `fprintf()` 函数都允许在输出字符串中插入依赖于语言的小数字符。小数字符在当前语言环境（类别 LC_NUMERIC）中定义。在 POSIX 语言环境中，或者在小数字符未定义的语言环境中，小数字符应默认为句点（'.'）。

每个转换说明由 '%' 字符或字符序列 "%n$" 引入，之后按顺序出现以下内容：

* 零个或多个标志（按任意顺序），这些标志修改转换说明的含义。
* 一个可选的最小字段宽度。如果转换后的值比字段宽度有更少的字节，则默认应在左侧用空格字符填充；如果给定了左对齐标志（'-'），则应在右侧填充。字段宽度采用星号（'*'）的形式，或者在由 "%n$" 引入的转换说明中采用下面描述的 "*m$" 字符串，或者采用十进制整数。
* 一个可选的精度，该精度给出 d、i、o、u、x 和 X 转换说明符要出现的最小数字位数；a、A、e、E、f 和 F 转换说明符的小数字符后要出现的数字位数；g 和 G 转换说明符的最大有效数字位数；或 s 转换说明符要从字符串打印的最大字节数。精度采用句点（'.'）后跟星号（'*'）的形式，或者在由 "%n$" 引入的转换说明中采用下面描述的 "*m$" 字符串，或者采用可选的十进制数字字符串，其中空数字字符串被视为零。如果精度与任何其他转换说明符一起出现，则行为未定义。
* 一个可选的长度修饰符，用于指定参数的大小。
* 一个转换说明符字符，指示要应用的转换类型。

字段宽度、精度或两者都可以用星号（'*'）表示。在这种情况下，`int` 类型的参数提供字段宽度或精度。应用程序应确保指定字段宽度、精度或两者的参数在被转换的参数（如果有）之前按该顺序出现。负字段宽度被视为 '-' 标志后跟正字段宽度。负精度被视为省略了精度。在包含由 "%n$" 引入的转换说明的格式字符串中，除了用十进制数字字符串表示外，字段宽度可以用序列 "*m$" 表示，精度用序列 ".*m$" 表示，其中 m 是范围 [1,{NL_ARGMAX}] 中的十进制整数，给出包含字段宽度或精度的整数参数在参数列表中的位置（在格式参数之后），例如：

```c
printf("%1$d:%2$.*3$d:%4$.*3$d\n", hour, min, precision, sec);
```

### 标志字符

标志字符及其含义是：

**'** (撇号)
十进制转换（%i、%d、%u、%f、%F、%g 或 %G）结果的整数部分应使用千位分组字符进行格式化。对于其他转换，行为未定义。使用非货币分组字符。

**-**
转换结果应在字段内左对齐。如果未指定此标志，则转换右对齐。

**+**
有符号转换的结果应始终以符号（'+' 或 '-'）开始。如果未指定此标志，则仅当转换负值时才以符号开始。

**空格**
如果有符号转换的第一个字符不是符号，或者有符号转换没有产生字符，则应在结果前添加空格。这意味着如果空格和 '+' 标志都出现，则忽略空格标志。

**#**
指定值要转换为替代形式。对于 o 转换，它应在必要时增加精度，以强制结果的第一个数字为零（如果值和精度都为 0，则打印单个 0）。对于 x 或 X 转换说明符，非零结果应前缀 0x（或 0X）。对于 a、A、e、E、f、F、g 和 G 转换说明符，结果应始终包含小数字符，即使小数字符后没有数字。没有此标志，仅当小数字符后跟数字时，这些转换的结果中才会出现小数字符。对于 g 和 G 转换说明符，尾随零不应像通常那样从结果中移除。对于其他转换说明符，行为未定义。

**0**
对于 d、i、o、u、x、X、a、A、e、E、f、F、g 和 G 转换说明符，使用前导零（跟在任何符号或基数指示之后）来填充到字段宽度，而不是执行空格填充，除非转换无穷大或 NaN。如果 '0' 和 '-' 标志都出现，则忽略 '0' 标志。对于 d、i、o、u、x 和 X 转换说明符，如果指定了精度，则忽略 '0' 标志。如果 '0' 和撇号标志都出现，则在零填充之前插入分组字符。对于其他转换，行为未定义。

### 长度修饰符

长度修饰符及其含义是：

**hh**
指定后续的 d、i、o、u、x 或 X 转换说明符应用于 `signed char` 或 `unsigned char` 参数（参数将根据整数提升进行提升，但其值应在打印前转换为 `signed char` 或 `unsigned char`）；或指定后续的 n 转换说明符应用于指向 `signed char` 参数的指针。

**h**
指定后续的 d、i、o、u、x 或 X 转换说明符应用于 `short` 或 `unsigned short` 参数（参数将根据整数提升进行提升，但其值应在打印前转换为 `short` 或 `unsigned short`）；或指定后续的 n 转换说明符应用于指向 `short` 参数的指针。

**l** (ell)
指定后续的 d、i、o、u、x 或 X 转换说明符应用于 `long` 或 `unsigned long` 参数；指定后续的 n 转换说明符应用于指向 `long` 参数的指针；指定后续的 c 转换说明符应用于 `wint_t` 参数；指定后续的 s 转换说明符应用于指向 `wchar_t` 参数的指针；或对后续的 a、A、e、E、f、F、g 或 G 转换说明符没有影响。

**ll** (ell-ell)
指定后续的 d、i、o、u、x 或 X 转换说明符应用于 `long long` 或 `unsigned long long` 参数；或指定后续的 n 转换说明符应用于指向 `long long` 参数的指针。

**j**
指定后续的 d、i、o、u、x 或 X 转换说明符应用于 `intmax_t` 或 `uintmax_t` 参数；或指定后续的 n 转换说明符应用于指向 `intmax_t` 参数的指针。

**z**
指定后续的 d、i、o、u、x 或 X 转换说明符应用于 `size_t` 或相应的有符号整数类型参数；或指定后续的 n 转换说明符应用于指向对应于 `size_t` 参数的有符号整数类型的指针。

**t**
指定后续的 d、i、o、u、x 或 X 转换说明符应用于 `ptrdiff_t` 或相应的无符号类型参数；或指定后续的 n 转换说明符应用于指向 `ptrdiff_t` 参数的指针。

**L**
指定后续的 a、A、e、E、f、F、g 或 G 转换说明符应用于 `long double` 参数。

如果长度修饰符与除上述指定之外的任何转换说明符一起出现，则行为未定义。

### 转换说明符

转换说明符及其含义是：

**d, i**
`int` 参数应转换为 "[-]dddd" 样式的有符号十进制。精度指定要出现的最小数字位数；如果要转换的值可以用更少的位数表示，则应使用前导零扩展。默认精度为 1。将零转换为显式精度为零的结果应为无字符。

**o**
`unsigned` 参数应转换为 "dddd" 样式的无符号八进制格式。精度指定要出现的最小数字位数；如果要转换的值可以用更少的位数表示，则应使用前导零扩展。默认精度为 1。将零转换为显式精度为零的结果应为无字符。

**u**
`unsigned` 参数应转换为 "dddd" 样式的无符号十进制格式。精度指定要出现的最小数字位数；如果要转换的值可以用更少的位数表示，则应使用前导零扩展。默认精度为 1。将零转换为显式精度为零的结果应为无字符。

**x**
`unsigned` 参数应转换为 "dddd" 样式的无符号十六进制格式；使用字母 "abcdef"。精度指定要出现的最小数字位数；如果要转换的值可以用更少的位数表示，则应使用前导零扩展。默认精度为 1。将零转换为显式精度为零的结果应为无字符。

**X**
等价于 x 转换说明符，但使用字母 "ABCDEF" 而不是 "abcdef"。

**f, F**
`double` 参数应转换为 "[-]ddd.ddd" 样式的十进制表示法，其中小数字符后的数字位数等于精度规范。如果缺少精度，则应取为 6；如果精度显式为零且没有 '#' 标志，则不应出现小数字符。如果出现小数字符，则在其前面至少出现一个数字。低位数字应以实现定义的方式四舍五入。

表示无穷大的 `double` 参数应以 "[-]inf" 或 "[-]infinity" 样式之一转换；使用哪种样式是实现定义的。表示 NaN 的 `double` 参数应以 "[-]nan(n-char-sequence)" 或 "[-]nan" 样式之一转换；使用哪种样式以及任何 n-char-sequence 的含义是实现定义的。F 转换说明符分别产生 "INF"、"INFINITY" 或 "NAN"，而不是 "inf"、"infinity" 或 "nan"。

**e, E**
`double` 参数应转换为 "[-]d.ddd e±dd" 样式，其中小数字符前有一个数字（如果参数非零则非零），其后的数字位数等于精度；如果缺少精度，则应取为 6；如果精度为零且没有 '#' 标志，则不应出现小数字符。低位数字应以实现定义的方式四舍五入。E 转换说明符应产生以 'E' 而不是 'e' 引入指数的数字。指数应始终包含至少两位数字。如果值为零，则指数应为零。

表示无穷大或 NaN 的 `double` 参数应以 f 或 F 转换说明符的样式转换。

**g, G**
表示浮点数的 `double` 参数应根据转换的值和精度以 f 或 e 样式（或在 G 转换说明符的情况下以 F 或 E 样式）转换。设 P 等于精度（如果非零）、省略精度时为 6，或精度为零时为 1。那么，如果使用样式 E 的转换将具有指数 X：

* 如果 P > X >= -4，则转换应使用样式 f（或 F）和精度 P-(X+1)。
* 否则，转换应使用样式 e（或 E）和精度 P-1。

最后，除非使用 '#' 标志，否则应从结果的小数部分移除任何尾随零，如果没有剩余的小数部分，则移除小数点字符。

表示无穷大或 NaN 的 `double` 参数应以 f 或 F 转换说明符的样式转换。

**a, A**
表示浮点数的 `double` 参数应转换为 "[-]0x h.hhhhp±d" 样式，其中小数字符前有一个十六进制数字（如果参数是归一化浮点数则非零，否则未指定），其后的十六进制数字位数等于精度；如果缺少精度，则应取为足够表示浮点数的精确值，如果精度为零且没有 '#' 标志，则不应出现小数字符。a 转换使用字母 "abcdef"，A 转换使用字母 "ABCDEF"。A 转换说明符产生使用 'X' 和 'P' 而不是 'x' 和 'p' 的数字。指数应始终包含至少一个数字，且仅包含表示 2 的十进制指数所需的更多数字。

表示无穷大或 NaN 的 `double` 参数应以 f 或 F 转换说明符的样式转换。

**c**
如果没有 l 长度修饰符，则 `int` 参数应转换为 `unsigned char`，结果字节应被写入。

如果有 l 长度修饰符，则 `wint_t` 参数应如同通过调用 `wcrtomb()` 且没有状态一样转换，结果的多字节字符应被写入。

**s**
如果没有 l 长度修饰符，应用程序应确保参数是指向字符数组的指针，该数组包含以初始移位状态开始的字符序列。应写入数组中的字符直到（但不包括）终止空字节。如果指定了精度，则不应写入超过该数量的字节，并且不应写入任何部分多字节字符。如果未指定精度或精度大于数组的大小，应用程序应确保数组包含空字节。

如果有 l 长度修饰符，应用程序应确保参数是指向 `wchar_t` 类型数组的指针。数组中的宽字符应转换为多字节字符（每个如同通过调用 `wcrtomb()` 转换，转换状态由在第一个宽字符转换之前初始化为零的 mbstate_t 对象描述），结果的多字节字符应被写入直到（但不包括）终止空宽字符。如果指定了精度，则不应写入超过该数量的字节，并且不应写入任何部分多字节字符。如果未指定精度或精度大于转换后的宽字符序列的大小，应用程序应确保数组包含空宽字符。

**p**
应用程序应确保参数是指向 `void` 的指针。指针的值以实现定义的方式转换为可打印字符序列。

**n**
应用程序应确保参数是指向整数的指针，该整数中写入此调用到 `fprintf()` 函数之一到目前为止写入输出流的字节数。不转换任何参数。格式字符串应按原样写入输出；如果转换说明包含字段宽度或精度，则写入输出的字节数的值应如同指定了这些值一样确定。

对于 `snprintf()`，这意味着如果 n 足够大，则本应写入缓冲区 s 的字节数，不包括终止空字节。

**%**
应写入 '%' 字符。不转换任何参数。完整的转换说明应为 "%%"。

如果转换说明不匹配上述形式之一，则行为未定义。

## RETURN VALUE

成功完成后，`fprintf()`、`printf()`、`dprintf()`、`snprintf()`、`asprintf()` 和 `sprintf()` 函数应返回传输的字节数。

如果遇到输出错误，这些函数应返回负值。

如果在调用 `snprintf()` 时 n 的值为零，则不应写入任何内容，应返回如果 n 足够大本应写入的字节数，且 s 可能为空指针。

## ERRORS

如果出现以下情况，函数将失败：

**EILSEQ**
在宽字符转换中检测到非法字节序列。

**EOVERFLOW**
要存储的值大于相应类型的整数。

`fprintf()`、`printf()`、`dprintf()`、`snprintf()` 和 `sprintf()` 函数在以下情况下可能失败：

**ENOMEM**
可用的存储空间不足。

`snprintf()` 函数在以下情况下将失败：

**EOVERFLOW**
n 的值大于 {INT_MAX} 或提供的存储空间不足。

`asprintf()` 函数在以下情况下将失败：

**ENOMEM**
可用的内存空间不足以存储结果字符串。

`dprintf()` 函数在以下情况下将失败：

**EBADF**
流底层的文件描述符不是有效的文件描述符或未打开用于写入。

`fprintf()` 和 `printf()` 函数在以下情况下可能失败：

**ENOMEM**
可用的存储空间不足。

**EILSEQ**
检测到不对应有效字符的宽字符代码。

## EXAMPLES

### 示例 1：打印与语言无关的日期和时间

以下语句可用于以与语言无关的方式打印日期和时间：

```c
printf (format, weekday, month, day, hour, min);
```

对于美国用法，`format` 可以是指向以下字符串的指针：

```c
"%s, %s %d, %.2d:%.2d\n"
```

此示例可能产生以下输出：

```
Sunday, July 3, 10:02
```

对于德国用法，`format` 可以是指向以下字符串的指针：

```c
"%1$s, %3$d. %2$s, %4$02.2d:%5$02.2d\n"
```

此 `format` 定义可能产生以下输出：

```
Sonntag, 3. Juli, 10:02
```

### 示例 2：打印文件列表

要以 Sunday, July 3, 10:02 的形式打印日期和时间，其中 weekday 和 month 是指向以空字符结尾的字符串的指针：

```c
printf("%s, %s %d, %.2d:%.2d\n", weekday, month, day, hour, min);
```

要将 pi 打印到 5 位小数：

```c
printf("pi = %.5f\n", 3.1415926535);
```

上述示例可能产生以下输出：

```
pi = 3.14159
```

### 示例 3：打印到不同目标

```c
#include <stdio.h>
#include <stdlib.h>

int main(void) {
    char buffer[100];
    char *dynamic_buffer = NULL;
    int ret;

    /* 写入标准输出 */
    ret = printf("Hello, World!\n");

    /* 写入缓冲区 */
    ret = sprintf(buffer, "Count: %d", 42);

    /* 写入带大小限制的缓冲区 */
    ret = snprintf(buffer, sizeof(buffer), "Value: %f", 3.14159);

    /* 写入动态分配的缓冲区 */
    ret = asprintf(&dynamic_buffer, "String: %s", "Dynamic");
    if (ret != -1) {
        printf("Allocated: %s\n", dynamic_buffer);
        free(dynamic_buffer);
    }

    return 0;
}
```

## APPLICATION USAGE

在调用 `asprintf()` 之前，`*ptr` 的值是不确定的，不应假定为 `NULL`。如果调用成功，应用程序应使用 `free()` 释放由 `asprintf()` 分配的内存。

## RATIONALE

`sprintf()` 函数容易出现缓冲区溢出。创建 `snprintf()` 函数是为了通过限制写入缓冲区的字节数来解决此安全问题。

添加 `asprintf()` 函数是为了处理程序员事先不知道格式化输出需要多大缓冲区的常见情况。

编号参数说明（"%n$"）为词序与英语不同的语言提供支持，允许重新排序格式字符串而不更改函数调用中的参数顺序。

## FUTURE DIRECTIONS

无。

## SEE ALSO

`fclose()`, `fopen()`, `fputc()`, `puts()`, `scanf()`, `wcrtomb()`

---

*The Open Group Base Specifications Issue 8, IEEE Std 1003.1-2024*
*版权所有 © 2001-2024 IEEE 和 The Open Group*