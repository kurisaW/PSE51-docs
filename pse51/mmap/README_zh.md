# mmap

## 概要

```c
#include <sys/mman.h>

void *mmap(void *addr, size_t len, int prot, int flags,
           int fildes, off_t off);
```

## 描述

`mmap()` 函数应在进程的地址空间和内存对象之间建立映射关系。

`mmap()` 函数应支持以下内存对象：

- 常规文件
- 匿名��存对象
- [SHM] 共享内存对象
- [TYM] 类型化内存对象

对于任何其他类型的文件的支持是未指定的。

调用的格式如下：

```
pa = mmap(addr, len, prot, flags, fildes, off);
```

`mmap()` 函数应在进程地址空间的地址 `pa` 处为 `len` 字节到由文件描述符 `fildes` 表示的内存对象的偏移量 `off` 处的 `len` 字节之间建立映射，或者到 `len` 字节的匿名内存对象。`pa` 的值是参数 `addr` 和 `flags` 值的实现定义函数，进一步描述如下。成功的 `mmap()` 调用应返回 `pa` 作为其结果。从 `pa` 开始并继续 `len` 字节的地址范围对于进程的可能（不一定当前）地址空间应是合法的。从 `off` 开始并继续 `len` 字节的字节范围对于由 `fildes` 表示的内存对象的可能（不一定当前）偏移量应是合法的。

[TYM] 如果 `fildes` 表示使用 POSIX_TYPED_MEM_ALLOCATE 标志或 POSIX_TYPED_MEM_ALLOCATE_CONTIG 标志打开的类型化内存对象，要映射的内存对象应是实现按如下规定分配的类型化内存对象的那部分。在这种情况下，如果 `off` 非零，`mmap()` 的行为是未定义的。如果 `fildes` 引用从调用进程不可访问的有效类型化内存对象，`mmap()` 应失败。

由 `mmap()` 建立的映射应替换包含从 `pa` 开始并继续 `len` 字节的进程地址空间任何部分的那些整个页面的任何先前映射。

如果在调用 `mmap()` 后映射文件的大小由于对映射文件的某些其他操作而改变，对映射区域中对应于文件添加或删除部分的引用的影响是未指定的。

如果 `len` 为零，`mmap()` 应失败且不建立映射。

参数 `prot` 决定是否允许对要映射的数据进行读、写、执行或某种组合访问。`prot` 应是 PROT_NONE 或下表中在 `<sys/mman.h>` 头文件中定义的其他一个或多个标志的按位包含或。

| 符号常量 | 描述 |
|-------------------|-------------|
| PROT_READ         | 数据可读取。 |
| PROT_WRITE        | 数据可写入。 |
| PROT_EXEC         | 数据可执行。 |
| PROT_NONE         | 数据不可访问。 |

如果实现无法支持 `prot` 指定的访问类型组合，`mmap()` 调用应失败。

实现可以允许除 `prot` 指定的访问之外的访问；但是，实现不应允许在未设置 PROT_WRITE 时写入成功，也不应在仅设置 PROT_NONE 时允许任何访问。实现应至少支持以下 `prot` 值：PROT_NONE、PROT_READ、PROT_WRITE 以及 PROT_READ 和 PROT_WRITE 的按位包含或。文件描述符 `fildes` 应已以读权限打开，无论指定的保护选项如何。如果指定了 PROT_WRITE，应用程序应确保已以写权限打开文件描述符 `fildes`，除非在 `flags` 参数中指定了 MAP_PRIVATE，如下所述。

参数 `flags` 提供关于处理映射数据的其他信息。`flags` 的值是这些选项的按位包含或，在 `<sys/mman.h>` 中定义：

| 符号常量 | 描述 |
|-------------------|-------------|
| MAP_ANON          | MAP_ANONYMOUS 的同义词。 |
| MAP_ANONYMOUS     | 映射匿名内存。 |
| MAP_SHARED        | 更改是共享的。 |
| MAP_PRIVATE       | 更改是私有的。 |
| MAP_FIXED         | 精确解释 addr。 |

是否支持 MAP_FIXED 是实现定义的。[XSI] 在符合 XSI 的系统上应支持 MAP_FIXED。

MAP_SHARED 和 MAP_PRIVATE 描述对内存对象的写引用的处理。如果指定了 MAP_SHARED，写引用应更改基础对象。如果指定了 MAP_PRIVATE，调用进程对映射数据的修改仅对调用进程可见，且不应更改基础对象。在建立 MAP_PRIVATE 映射后，对基础对象的修改是否通过 MAP_PRIVATE 映射可见是未指定的。可以指定 MAP_SHARED 或 MAP_PRIVATE，但不能同时指定两者。映射类型在 `fork()` 调用中保持不变。

当任何进程中包含同步对象的最后一个区域取消映射时，放置在使用 MAP_SHARED 映射的共享内存中的互斥锁、信号量、屏障和条件变量等同步对象的状态变为未定义。

[TYM] 当 `fildes` 表示使用 POSIX_TYPED_MEM_ALLOCATE 标志或 POSIX_TYPED_MEM_ALLOCATE_CONTIG 标志打开的类型化内存对象时，`mmap()` 应在有足够可用资源的情况下，映射从相应类型化内存对象分配的 `len` 字节，这些字节先前未分配给可能访问该类型化内存对象的任何处理器中的任何进程。如果没有足够的可用资源，函数应失败。如果 `fildes` 表示使用 POSIX_TYPED_MEM_ALLOCATE_CONTIG 标志打开的类型化内存对象，这些分配的字节在类型化内存对象内应是连续的。如果 `fildes` 表示使用 POSIX_TYPED_MEM_ALLOCATE 标志打开的类型化内存对象，这些分配的字节可能由类型化内存对象内的非连续片段组成。如果 `fildes` 表示既未使用 POSIX_TYPED_MEM_ALLOCATE_CONTIG 标志也未使用 POSIX_TYPED_MEM_ALLOCATE 标志打开的类型化内存对象，则映射类型化内存对象内从偏移量 `off` 开始的 `len` 字节，与映射文件或共享内存对象时完全相同。在这种情况下，如果两个进程使用相同的 `off` 和 `len` 值以及引用相同内存池（来自同一端口或不同端口）的文件描述符映射类型化内存的区域，两个进程应映射相同的存储区域。

在 `flags` 参数中设置 MAP_FIXED 时，通知实现 `pa` 的值应完全是 `addr`。如果设置了 MAP_FIXED，`mmap()` 可能返回 MAP_FAILED 并将 `errno` 设置为 [EINVAL]。如果 MAP_FIXED 请求成功，则在建立新映射之前，应删除包含地址范围 [`pa`,`pa`+`len`) 任何部分的那些整个页面的任何先前映射 [ML|MLR] 或内存锁定，就像通过适当的 `munmap()` 调用一样。

当未设置 MAP_FIXED 时，实现以实现定义的方式使用 `addr` 来得出 `pa`。这样选择的 `pa` 应是实现认为适合将 `len` 字节映射到文件的地址空间区域。所有实现将 `addr` 值 0 解释为授予实现在选择 `pa` 时的完全自由，但要受下面描述的约束。`addr` 的非零值被看作是放置映射的进程地址的建议。当实现为 `pa` 选择值时，它永远不会将映射放置在地址 0 处，也不会替换任何现有映射。

如果指定了 MAP_FIXED 且 `addr` 非零，它应具有与 `off` 参数相同的余数，以页大小为模，该页大小通过向 `sysconf()` 传递 _SC_PAGESIZE 或 _SC_PAGE_SIZE 返回。实现可能要求 `off` 是页大小的倍数。如果指定了 MAP_FIXED，实现可能要求 `addr` 是页大小的倍数。系统对整个页面执行映射操作。因此，虽然参数 `len` 不需要满足大小或对齐约束，但系统应在任何映射操作中包含从 `pa` 开始并继续 `len` 字节的地址范围指定的任何部分页面。

如果指定了 MAP_ANONYMOUS（或其同义词 MAP_ANON），`fildes` 为 -1，`off` 为 0，则 `mmap()` 应忽略 `fildes`，而是建立到大小为 `len` 的新匿名内存对象的映射。将 MAP_ANONYMOUS（或 MAP_ANON）与 `fildes` 或 `off` 的其他值一起指定的效果是未指定的。匿名内存对象应初始化为全零。

系统应始终在对象末尾用零填充任何部分页面。此外，系统永远不会写出对象最后一页超出其末尾的任何修改部分。在从 `pa` 开始并继续 `len` 字节的地址范围内对对象末尾之后的整个页面的引用应导致传送 SIGBUS 信号。

当引用会导致映射对象中的错误（如空间不足条件）时，实现可能生成 SIGBUS 信号。

`mmap()` 函数应向与文件描述符 `fildes` 关联的文件添加额外引用，该引用不会通过后续对该文件描述符的 `close()` 调用来移除。当文件不再有映射时，应移除此引用。

映射文件的最后数据访问时间戳可能在 `mmap()` 调用和相应的 `munmap()` 调用之间的任何时间被标记为更新。对映射区域的初始读或写引用应导致文件的最后数据访问时间戳被标记为更新（如果尚未被标记为更新）。

使用 MAP_SHARED 和 PROT_WRITE 映射的文件的最后数据修改和最后文件状态更改时间戳应在对映射区域的写引用和任何进程对该部分文件的下一次使用 MS_ASYNC 或 MS_SYNC 调用 `msync()` 之间的某个时间点被标记为更新。如果没有这样的调用，并且如果基础文件由于写引用而被修改，那么这些时间戳应在写引用后的某个时间被标记为更新。

可能存在实现定义的限制，限制可映射的内存区域数量（每个进程或每个系统）。

[XSI] 如果施加了这样的限制，进程可映射的内存区域数量是否因使用 `shmat()` 而减少是实现定义的。

如果 `mmap()` 因 [EBADF]、[EINVAL] 或 [ENOTSUP] 以外的原因失败，从 `addr` 开始并继续 `len` 字节的地址范围中的一些映射可能已被取消映射。

## 返回值

成功完成后，`mmap()` 函数应返回映射放置的地址（`pa`）；否则，应返回 MAP_FAILED 值并设置 `errno` 以指示错误。符号 MAP_FAILED 在 `<sys/mman.h>` 头文件中定义。`mmap()` 的任何成功返回都不应返回 MAP_FAILED 值。

## 错误

在以下情况下，`mmap()` 函数应失败：

[EAGAIN]
[ML] 如果 `mlockall()` 要求，由于资源缺乏，映射无法锁定在内存中。

[EINVAL]
`len` 的值为零。

[EINVAL]
`flags` 的值无效（既未设置 MAP_PRIVATE 也未设置 MAP_SHARED）。

[EMFILE]
映射区域数量将超过实现定义的限制（每个进程或每个系统）。

[ENOMEM]
指定了 MAP_FIXED，并且范围 [`addr`,`addr`+`len`) 超过了进程地址空间允许的范围；或者，如果未指定 MAP_FIXED，并且地址空间中没有足够的空间来建立映射。

[ENOMEM]
[ML] 如果 `mlockall()` 要求，由于需要比系统能够提供的更多空间，映射无法锁定在内存中。

[ENOMEM]
[TYM] 由 `fildes` 指定的类型化内存对象中剩余的未分配内存资源不足以分配 `len` 字节。

[ENOTSUP]
在 `flags` 参数中指定了 MAP_FIXED 或 MAP_PRIVATE，而实现不支持此功能。

实现不支持 `prot` 参数中请求的访问组合。

[ENXIO]
在 `flags` 中指定了 MAP_FIXED，并且 `addr`、`len` 和 `off` 的组合对于指定对象无效。

[ENXIO]
[TYM] `fildes` 参数引用从调用进程不可访问的类型化内存对象。

此外，如果 flags 中未设置 MAP_ANONYMOUS（或 MAP_ANON），在以下情况下 `mmap()` 函数应失败：

[EACCES]
`fildes` 参数未以读权限打开，无论指定何种保护，或者 `fildes` 未以写权限打开，并且为 MAP_SHARED 类型映射指定了 PROT_WRITE。

[EBADF]
`fildes` 参数不是有效的打开文件描述符。

[ENODEV]
`fildes` 参数引用 `mmap()` 不支持的文件类型。

[EOVERFLOW]
文件是常规文件，并且 `off` 加 `len` 的值超过与 `fildes` 关联的打开文件描述中建立的偏移量最大值。

[ENXIO]
对于 `fildes` 指定的对象，范围 [`off`,`off`+`len`) 中的地址无效。

在以下情况下，`mmap()` 函数可能失败：

[EINVAL]
`addr` 参数（如果指定了 MAP_FIXED）或 `off` 不是 `sysconf()` 返回的页大小的倍数，或者被实现认为是无效的。

---

## 示例

无。

## 应用程序用法

使用 `mmap()` 可能会减少可用于其他内存分配函数的内存量。

使用 MAP_FIXED 可能导致在进一步使用 `malloc()` 和 `shmat()` 时出现未定义行为。不鼓励使用 MAP_FIXED，因为它可能阻止实现最有效地利用资源。大多数实现要求 `off` 和 `addr` 是 `sysconf()` 返回的页大小的倍数。

当将 `mmap()` 与任何其他文件访问方法（如 `read()` 和 `write()`、标准输入/输出和 `shmat()`）结合使用时，应用程序必须确保正确的同步。

`mmap()` 函数允许通过地址空间操作而不是 `read()`/`write()` 来访问资源。一旦文件被映射，进程访问它所需要做的就是使用文件映射到的地址处的数据。因此，使用伪代码来说明现有程序可能更改为使用 `mmap()` 的方式，如下所示：

```c
fildes = open(...)
lseek(fildes, some_offset)
read(fildes, buf, len)
/* 使用 buf 中的数据。 */
```

变为：

```c
fildes = open(...)
address = mmap(0, len, PROT_READ, MAP_PRIVATE, fildes, some_offset)
/* 使用 address 处的数据。 */
```

## 原理

在考虑了几个其他替代方案后，决定采用在 SVR4 中找到的 `mmap()` 定义，用于将内存对象映射到进程地址空间。SVR4 定义是最小的，因为它只描述了已构建的内容，以及对于通用和可移植映射设施看起来必要的内容。

请注意，虽然 `mmap()` 最初是为映射文件设计的，但它实际上是一个通用映射设施。它可用于将任何适当的对象（如内存、文件、设备等）映射到进程的地址空间。

建立映射时，由于硬件要���，实现可能需要在进程地址空间中映射比请求更多的内容。但是，应用程序不能依赖这种行为。不使用分页架构的实现可能只是分配一个公共内存区域并返回其地址；这样的实现可能不会分配超出必要的内容。对请求区域末尾之外的引用是未指定的。

如果应用程序请求的映射与进程中的现有映射重叠，可能希望实现检测到这一点并通知应用程序。但是，如果程序指定了固定地址映射（如果支持该功能，需要一些实现知识来确定合适的地址），那么程序被假定为成功地管理自己的地址空间，当请求映射到现有数据结构上时应该被信任。此外，还希望尽可能少地进行系统调用，在相同地址范围的 `mmap()` 之前要求 `munmap()` 可能被认为是繁重的。POSIX.1-2024 卷指定新映射替换任何现有映射（意味着对地址范围的自动 `munmap()`），遵循这方面的现有实践。标准开发者还考虑了是否应该有一种方式让新映射覆盖现有映射，但没有发现这方面的现有实践。

并不期望所有硬件实现都能在所有地址上支持所有权限组合。要求实现禁止对没有写权限的映射进行写访问，并禁止对没有任何访问权限的映射进行任何访问。除了这些限制外，实现可以允许应用程序请求的访问类型之外的访问类型。例如，如果应用程序仅请求 PROT_WRITE，实现也可以允许读访问。如果实现无法支持允许应用程序请求的所有访问，`mmap()` 调用失败。例如，一些实现不能同时支持写访问和执行访问的请求。所有实现必须支持无访问、读访问、写访问以及读和写访问的请求。严格符合的代码只能依赖所需的检查。这些限制允许在各种硬件上具有可移植性。

MAP_FIXED 地址处理对于非页对齐值和某些依赖架构的地址范围可能会失败。符合的实现不能指望能够在不利用不可移植、实现定义的知识的情况下为 MAP_FIXED 选择地址值。尽管如此，MAP_FIXED 作为符合现有实践的标准接口提供，用于在可用时利用此类知识。

类似地，为了允许不支持虚拟地址的实现，不要求支持通过 MAP_FIXED 直接指定任何映射地址，因此符合的应用程序可能不能依赖它。

当内存保护硬件可用时，MAP_PRIVATE 函数可以高效实现。当这样的硬件不可用时，实现可以通过简单地将相关数据的实际副本制作到进程私有内存中来实现此类"映射"，尽管这往往与 `read()` 表现相似。

该函数已被定义为允许许多不同的使用共享内存的模型。但是，并非所有用途在所有机器架构上都同样可移植。特别是，`mmap()` 函数允许系统和应用程序指定将内存对象的特定区域映射到的地址。使用函数的最可移植方式始终是让系统选择地址，指定 NULL 作为 `addr` 参数的值，并且不指定 MAP_FIXED。

如果打算将内存对象的特定区域映射到一组进程中的相同地址（在甚至可能的机器上），那么可以使用 MAP_FIXED 传入所需的映射地址。如果第一次这样的映射是在未指定 MAP_FIXED 的情况下进行的，系统仍然可以用来选择所需的地址，然后生成的映射地址可以传递给后续进程，以便它们通过 MAP_FIXED 传入。通常不能保证特定地址范围的可用性。

`mmap()` 函数可用于映射大于对象当前大小的内存区域。在映射内但超出基础对象当前末尾的内存访问可能导致向进程发送 SIGBUS 信号。原因是对象的大小可能被其他进程操纵，并且可以随时更改。实现应告诉应用程序内存引用在对象之外，在可以检测到的情况下；否则，写入的数据可能会丢失，读取的数据可能不会反映对象中的实际数据。

请注意，对对象末尾之外的引用不会扩展对象，因为新的末尾无法被大多数虚拟内存硬件精确确定。相反，大小可以直接通过 `ftruncate()` 操纵。

进程内存锁定确实适用于共享内存区域，`mlockall()` 的 MCL_FUTURE 参数可用于确保新的共享内存区域被自动锁定。

`mmap()` 的现有实现在不成功时返回值 -1。由于 ISO C 标准无法保证将此值强制转换为 `void *` 类型与成功值不同，POSIX.1-2024 卷定义了符号 MAP_FAILED，符合的实现不将其作为成功调用的结果返回。

一些历史实现仅支持 MAP_ANON，一些仅支持 MAP_ANONYMOUS，一些支持两种拼写。本标准包含两种拼写，部分是为了应用程序兼容性，部分因为在考虑此功能标准化时，没有哪种拼写明显比另一种更流行。

## 未来方向

无。

## 另请参阅

`exec`、`fcntl()`、`fork()`、`lockf()`、`msync()`、`munmap()`、`mprotect()`、`posix_typed_mem_open()`、`shmat()`、`sysconf()`

XBD `<sys/mman.h>`

## 更改历史

首次在版本 4 的第 2 版中发布。

### 版本 5

从 X/OPEN UNIX 扩展移动到 BASE。

与 POSIX Realtime Extension 中的 `mmap()` 对齐如下：

- 描述被广泛重写。
- 添加了 [EAGAIN] 和 [ENOTSUP] 强制错误条件。
- 添加了 [ENOMEM] 和 [ENXIO] 的新案例作为强制错误条件。
- 失败时返回的值是常量 MAP_FAILED 的值；这之前被定义为 -1。

添加了 Large File Summit 扩展。

### 版本 6

`mmap()` 函数被标记为内存映射文件选项的一部分。

应用了 The Open Group Corrigendum U028/6，将 `(void *)`-1 更改为 MAP_FAILED。

以下对 POSIX 实现的新要求源自与 Single UNIX Specification 的对齐：

- 更新描述以描述 MAP_FIXED 的使用。
- 更新描述以描述向传递给 `mmap()` 的文件描述符关联的文件添加额外引用。
- 更新描述以说明可能存在对可映射内存区域数量的实现定义限制。
- 更新描述以描述 `off` 参数的对齐和大小约束。
- 添加了 [EINVAL] 和 [EMFILE] 错误条件。
- 添加了 [EOVERFLOW] 错误条件。此更改是为了支持大文件。

为了与 ISO POSIX-1:1996 标准对齐，进行了以下更改：

- 更新描述以描述 MAP_PRIVATE 和 MAP_FIXED 不需要支持的情况。

为了与 IEEE Std 1003.1j-2000 对齐，进行了以下更改：

- 在描述中添加了类型化内存对象的语义。
- 在错误部分添加了新的 [ENOMEM] 和 [ENXIO] 错误。
- 将 `posix_typed_mem_open()` 函数添加到"另请参阅"部分。

更新规范文本以避免对应用程序要求使用"必须"一词。

应用了 IEEE Std 1003.1-2001/Cor 1-2002，项目 XSH/TC1/D6/34，将概要中的边距代码从 MF|SHM 更改为 MC3（MF|SHM|TYM 的表示法）。

应用了 IEEE Std 1003.1-2001/Cor 2-2004，项目 XSH/TC2/D6/60，更新描述和错误部分以在 `len` 为零时添加 [EINVAL] 错误。

### 版本 7

应用了 Austin Group Interpretations 1003.1-2001 #078 和 #079，阐明了页对齐要求，并添加了关于当共享区域取消映射时同步对象状态变为未定义的说明。

与内存保护和内存映射文件选项相关的功能被移动到基础。

进行了与支持细粒度时间戳相关的更改。

应用了 POSIX.1-2008，Technical Corrigendum 2，XSH/TC2-2008/0229 [852]。

### 版本 8

应用了 Austin Group Defect 850，添加了匿名内存对象。

---

信息性文本结束。

---

UNIX® 是 The Open Group 的注册商标。
POSIX™ 是 IEEE 的商标。
版权所有 © 2001-2024 IEEE 和 The Open Group，保留所有权利