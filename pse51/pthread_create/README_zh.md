# pthread_create - 线程创建

## 概要

```c
#include <pthread.h>

int pthread_create(pthread_t *restrict thread,
                  const pthread_attr_t *restrict attr,
                  void *(*start_routine)(void*),
                  void *restrict arg);
```

## 描述

`pthread_create()` 函数应在进程内创建一个具有 `attr` 指定属性的新线程。如果 `attr` 为 NULL，则应使用默认属性。如果 `attr` 指定的属性在后续被修改，线程的属性不会受到影响。成功完成后，`pthread_create()` 应将创建的线程的 ID 存储在 `thread` 引用的位置。

线程被创建时执行 `start_routine`，以 `arg` 作为其唯一参数。如果 `start_routine` 返回，效果应如同隐式调用了 `pthread_exit()`，使用 `start_routine` 的返回值作为退出状态。注意，最初调用 `main()` 的线程与此不同。当它从 `main()` 返回时，效果应如同隐式调用了 `exit()`，使用 `main()` 的返回值作为退出状态。

### 信号状态初始化

新线程的信号状态应按如下方式初始化：

* 信号掩码应从创建线程继承。
* 新线程的待处理信号集合应为空。

线程局部的当前本地化设置 [XSI] 和备用栈不会被继承。

浮点环境应从创建线程继承。

如果 `pthread_create()` 失败，不会创建新线程，`thread` 引用的位置内容是未定义的。

[TCT] 如果定义了 `_POSIX_THREAD_CPUTIME`，新线程应有一个可访问的 CPU 时间时钟，该时钟的初始值应设置为零。

如果 `pthread_create()` 的 `attr` 参数指定的值不是指向已初始化的线程属性对象，则行为是未定义的。

## 返回值

如果成功，`pthread_create()` 函数应返回零；否则，应返回错误号以指示错误。

## 错误

`pthread_create()` 函数应在以下情况下失败：

**[EAGAIN]**
系统缺乏创建另一个线程所需的必要资源，或者系统强制的进程内线程总数限制 `{PTHREAD_THREADS_MAX}` 将被超过。

**[EPERM]**
调用者没有适当的权限来设置所需的调度参数或调度策略。

`pthread_create()` 函数不应返回 `[EINTR]` 错误码。

## 示例

无。

## 应用程序使用

实现没有要求在新创建的线程开始执行之前，创建线程的 ID 就必须可用。调用线程可以通过 `pthread_create()` 函数的 `thread` 参数获取创建线程的 ID，新创建的线程可以通过调用 `pthread_self()` 获取其 ID。

## 原理说明

建议的 `pthread_create()` 替代方案是定义两个独立的操作：创建和启动。一些应用程序会发现这种行为更自然。特别是 Ada 语言，将任务的"创建"与其"激活"分开。

标准开发者出于多种原因拒绝了将操作分开：

* 启动线程所需的调用次数会从一个增加到两个，从而给不需要额外同步的应用程序带来额外负担。但是，通过启动状态属性的额外复杂性，可以避免第二次调用。
* 会引入一个额外的状态："已创建但未启动"。这将要求标准指定目标尚未开始执行时线程操作的行为。
* 对于需要这种行为的应用程序，可以使用当前提供的设施来模拟两个独立的步骤。`start_routine()` 可以通过等待由启动操作发信号的条件变量来同步。

Ada 实现者可以选择在 Ada 程序的两个点创建线程：创建任务对象时，或激活任务时（通常在 "begin" 处）。如果采用第一种方法，`start_routine()` 需要等待条件变量以接收开始"激活"的命令。第二种方法不需要这样的条件变量或额外同步。无论采用哪种方法，在创建任务对象时都需要创建单独的 Ada 任务控制块来保存会合队列等。

前面模型的扩展将允许在线程创建和启动之间修改线程状态。这将允许消除线程属性对象。这被拒绝是因为：

* 线程属性对象中的所有状态都必须能够为线程设置。这将需要定义修改线程属性的函数。设置线程所需的函数调用次数不会减少。实际上，对于使用相同属性创建所有线程的应用程序，设置线程所需的函数调用次数会大幅增加。使用线程属性对象允许应用程序进行一组属性设置函数调用。否则，每次线程创建都需要进行属性设置函数调用。
* 根据实现架构，设置线程状态的函数可能需要内核调用，或者出于其他实现原因无法实现为宏，从而增加线程创建的成本。
* 应用程序按类别隔离线程的能力将丢失。

另一个建议的替代方案使用类似于进程创建的模型，如"线程 fork"。fork 语义将提供更多灵活性，"create"函数可以通过执行线程 fork 然后立即调用线程所需的"启动例程"来实现。这种替代方案有以下问题：

* 对于许多实现，需要复制调用线程的整个栈，因为在许多架构中无法确定调用帧的大小。
* 效率降低，因为必须复制至少部分栈，尽管在大多数情况下线程永远不需要复制的上下文，因为它只是调用所需的启动例程。

如果实现检测到 `pthread_create()` 的 `attr` 参数指定的值不是指向已初始化的线程属性对象，建议函数应失败并报告 `[EINVAL]` 错误。

## 未来方向

无。

## 另请参阅

* `fork()`
* `pthread_exit()`
* `pthread_join()`

XBD 4.15.2 内存同步，`<pthread.h>`

## 变更历史

### 首次发布于 Issue 5
为了与 POSIX 线程扩展对齐而包含。

### Issue 6
`pthread_create()` 函数被标记为线程选项的一部分。

以下对 POSIX 实现的新要求来源于与单一 UNIX 规范的对齐：

* 添加了 `[EPERM]` 强制错误条件。

为了与 IEEE Std 1003.1d-1999 对齐，添加了线程 CPU 时间时钟语义。

为了与 ISO/IEC 9899:1999 标准对齐，在 `pthread_create()` 原型中添加了 `restrict` 关键字。

更新描述以明确浮点环境从创建线程继承。

应用 IEEE Std 1003.1-2001/Cor 1-2002，项目 XSH/TC1/D6/44，添加备用栈不被继承的文本。

应用 IEEE Std 1003.1-2001/Cor 2-2004，项目 XSH/TC2/D6/93，更新错误部分以删除强制 `[EINVAL]` 错误（"`attr` 指定的值无效"），并添加可选 `[EINVAL]` 错误（"`attr` 指定的属性无效"）。

应用 IEEE Std 1003.1-2001/Cor 2-2004，项目 XSH/TC2/D6/94，添加应用程序使用部分。

### Issue 7
`pthread_create()` 函数从线程选项移至基础。

删除了未初始化线程属性对象的 `[EINVAL]` 错误；此条件导致未定义行为。

应用 POSIX.1-2008，技术勘误 1，XSH/TC1-2008/0458 [302]。

应用 POSIX.1-2008，技术勘误 2，XSH/TC2-2008/0274 [849]。

---
