# qsort, qsort_r — 数据表排序

## 概要

```c
#include <stdlib.h>

void qsort(void *base, size_t nel, size_t width,
           int (*compar)(const void *, const void *));

[CX] void qsort_r(void *base, size_t nel, size_t width,
                  int (*compar)(const void *, const void *, void *), void *arg);
```

## 描述

对于 `qsort()`：[CX] 本参考页描述的功能与 ISO C 标准保持一致。此处描述的要求与 ISO C 标准之间的任何冲突都是无意的。POSIX.1-2024 卷遵循 ISO C 标准。

`qsort()` 函数应对由 `nel` 个对象组成的数组进行排序，数组的首元素由 `base` 指向。每个对象的大小（以字节为单位）由 `width` 参数指定。如果 `nel` 参数值为零，则不应调用 `compar` 指向的比较函数，也不应进行任何重排。

应用程序应确保 `compar` 指向的比较函数不改变数组的内容。实现可以在比较函数调用之间重新排序数组的元素，但不应改变任何单个元素的内容。

当相同对象（由 width 字节组成，无论其在数组中的当前位置）被多次传递给比较函数时，结果应保持一致。也就是说，它们应定义数组上的全序关系。

数组的内容应根据比较函数按升序排序。`compar` 参数是指向比较函数的指针，该函数接收指向待比较元素的两个参数。应用程序应确保该函数返回小于、等于或大于 0 的整数，如果第一个参数被认为分别小于、等于或大于第二个参数。如果两个成员比较相等，它们在排序数组中的顺序是未指定的。

[CX] `qsort_r()` 函数应与 `qsort()` 完全相同，除了比较函数 `compar` 接受第三个参数。传递给 `qsort_r()` 的 `arg` 不透明指针应依次作为第三个参数传递给比较函数。

## 返回值

这些函数不应返回任何值。

## 错误

未定义错误。

## 应用程序用法

比较函数无需比较每个字节，因此元素中除了被比较的值之外，还可以包含任意数据。

如果 `compar` 回调函数需要超出待排序项目之外的任何额外状态，它只能通过全局变量访问该状态，这使得在不同线程中同时使用相同的 `compar` 函数调用 `qsort()` 可能不安全。`qsort_r()` 函数被添加，具有向比较器传递任意参数的能力，这避免了访问全局变量的需要，从而使得可以在线程间安全地共享有状态的比较器。

## 基本原理

要求比较函数的每个参数（下文称为 `p`）是数组元素的指针，这意味着对于每次调用，对于每个参数，以下所有表达式的值都非零：

```c
((char *)p - (char *)base) % width == 0
(char *)p >= (char *)base
(char *)p < (char *)base + nel * width
```

## 未来方向

无。

## 参见

- `alphasort()`
- `<stdlib.h>`

## 变更历史

首次发布于 Issue 1。源自 SVID 的 Issue 1。

### Issue 6

规范性文本被更新，以避免对应用程序要求使用术语"must"。

应用 IEEE Std 1003.1-2001/Cor 1-2002，条目 XSH/TC1/D6/49，在描述部分的第一个非阴影段落添加最后一句，以及接下来的两个段落。基本原理也被更新。这些更改是为了与 ISO C 标准保持一致。

### Issue 8

应用 Austin Group Defect 900，添加了 `qsort_r()` 函数。

---
