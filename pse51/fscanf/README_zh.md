# fscanf

## 名称

fscanf - 转换格式化输入

## 概要

```c
#include <stdio.h>

int fscanf(FILE *restrict stream, const char *restrict format, ...);
int scanf(const char *restrict format, ...);
int sscanf(const char *restrict s, const char *restrict format, ...);
```

## 描述

[CX] 本参考页描述的功能与ISO C标准一致。此处描述的要求与ISO C标准之间的任何冲突都是非故意的。本POSIX.1-2024卷遵循ISO C标准。

`fscanf()` 函数应从指定的输入流读取。`scanf()` 函数应从标准输入流stdin读取。`sscanf()` 函数应从字符串`s`读取。每个函数读取字节，根据格式进行解释，并将结果存储在其参数中。每个函数期望作为参数的是一个如下所述的控制字符串格式，以及一组指示转换后的输入应存储在何处的指针参数。如果格式参数不足，结果是未定义的。如果格式已耗尽但仍有参数剩余，多余参数应被求值但否则被忽略。

[CX] 转换可以应用于参数列表中格式之后的第n个参数，而不是下一个未使用的参数。在这种情况下，转换说明符字符%（见下文）被序列"%n$"替换，其中n是范围[1,{NL_ARGMAX}]内的十进制整数。此功能提供了定义按适合特定语言的顺序选择参数的格式字符串的方法。在包含"%n$"形式转换说明的格式字符串中，格式字符串是否可以多次引用参数列表中的编号参数是未指定的。

格式可以包含两种形式的转换说明符，即%或"%n$"，但两种形式不能在单个格式字符串中混合使用。唯一的例外是%%或%*可以与"%n$"形式混合使用。当使用编号参数规范时，指定第N个参数要求所有前导参数，从第一个到第(N-1)个，都是指针。

所有形式的`fscanf()`函数都应允许在输入字符串中检测依赖于语言的小数点字符。小数点字符在当前语言环境（类别LC_NUMERIC）中定义。在POSIX语言环境中，或在未定义小数点字符的语言环境中，小数点字符应默认为句点（'.'）。

### 格式字符串

应用程序应确保格式是字符字符串，如果存在，则以其初始移位状态开始和结束，由零个或多个指令组成。每个指令由以下内容之一组成：一个或多个空白字节；一个普通字符（既不是'%'也不是空白字节）；或一个转换说明。每个转换说明由字符'%' [CX]或字符序列"%n$"引入，之后按顺序出现以下内容：

* 可选的赋值抑制字符'*'。
* 可选的非零十进制整数，指定最大字段宽度。
* [CX] 可选的赋值分配字符'm'。
* 可选的长度修饰符，指定接收对象的大小。
* 转换说明符字符，指定要应用的转换类型。

`fscanf()`函数应依次执行格式的每个指令。当所有指令都已执行，或者如果指令失败（如下详述），函数应返回。失败被描述为输入失败（由于输入字节不可用）或匹配失败（由于不适当的输入）。

### 指令执行

由一个或多个空白字节组成的指令应通过读取输入直到第一个非空白字节来执行，该字节应保持未读状态，或者直到无法读取更多字节。该指令永远不会失败。

作为普通字符的指令应按以下方式执行：从输入中读取下一个字节，并与组成指令的字节进行比较；如果比较显示它们不等价，指令应失败，不同的和后续的字节应保持未读状态。类似地，如果文件结束、编码错误或读取错误阻止读取字符，指令应失败。

作为转换说明的指令定义了一组匹配输入序列，如下每个转换字符所述。转换说明应按以下步骤执行：

1. 应跳过输入空白字节，除非转换说明包含[、c、C或n转换说明符。
2. 应从输入中读取一个项目，除非转换说明包含n转换说明符。输入项目应定义为最长序列的输入字节（达到任何指定的最大字段宽度，该宽度可能根据转换说明符以字符或字节测量），它是匹配序列的初始子序列。输入项目之后的第一个字节（如果有）应保持未读状态。如果输入项目的长度为0，转换说明的执行应失败；这种情况是匹配失败，除非文件结束、编码错误或读取错误阻止从流读取输入，在这种情况下是输入失败。
3. 除了%转换说明符的情况外，输入项目（或者在%n转换说明符的情况下，输入字节的计数）应被转换为适合转换字符的类型。如果输入项目不是匹配序列，转换说明的执行失败；这种情况是匹配失败。除非赋值抑制由'*'指示，转换的结果应放置在格式参数之后尚未接收转换结果的第一个参数指向的对象中，如果转换说明由%引入，[CX]或者由字符序列"%n$"引入，则放在第n个参数中。如果此对象没有适当的类型，或者转换的结果无法在提供的空间中表示，则行为是未定义的。

[CX] c、s和[转换说明符应接受可选的赋值分配字符'm'，这将导致分配内存缓冲区来保存转换结果。如果转换说明符是s或[，分配的缓冲区应包括用于终止空字符（或宽字符）的空间。在这种情况下，对应于转换说明符的参数应该是指针变量的引用，该变量将接收指向分配缓冲区的指针。系统应分配缓冲区，就像调用了`malloc()`一样。应用程序应负责在使用后释放内存。如果没有足够的内存分配缓冲区，函数应将errno设置为[ENOMEM]并导致转换错误。如果函数返回EOF，此调用中使用赋值分配字符'm'为参数成功分配的任何内存应在函数返回前被释放。

### 长度修饰符

长度修饰符及其含义是：

**hh**
指定后续的d、i、o、u、x、X或n转换说明符应用于类型为`signed char`或`unsigned char`指针的参数。

**h**
指定后续的d、i、o、u、x、X或n转换说明符应用于类型为`short`或`unsigned short`指针的参数。

**l** (ell)
指定后续的d、i、o、u、x、X或n转换说明符应用于类型为`long`或`unsigned long`指针的参数；后续的a、A、e、E、f、F、g或G转换说明符应用于类型为`double`指针的参数；或者后续的c、s或[转换说明符应用于类型为`wchar_t`指针的参数。[CX]如果指定了'm'赋值分配字符，转换应用于类型为指向`wchar_t`指针的参数。

**ll** (ell-ell)
指定后续的d、i、o、u、x、X或n转换说明符应用于类型为`long long`或`unsigned long long`指针的参数。

**j**
指定后续的d、i、o、u、x、X或n转换说明符应用于类型为`intmax_t`或`uintmax_t`指针的参数。

**z**
指定后续的d、i、o、u、x、X或n转换说明符应用于类型为`size_t`或相应有符号整数类型的指针的参数。

**t**
指定后续的d、i、o、u、x、X或n转换说明符应用于类型为`ptrdiff_t`或相应的`unsigned`类型指针的参数。

**L**
指定后续的a、A、e、E、f、F、g或G转换说明符应用于类型为`long double`指针的参数。

如果长度修饰符与除上述指定之外的任何转换说明符一起出现，行为是未定义的。

### 转换说明符

以下转换说明符是有效的：

**d**
匹配可选有符号十进制整数，其格式与`strtol()`的主体序列期望的格式相同，base参数值为10。在没有大小修饰符的情况下，应用程序应确保相应参数是`int`指针。

**i**
匹配可选有符号整数，其格式与`strtol()`的主体序列期望的格式相同，base参数值为0。在没有大小修饰符的情况下，应用程序应确保相应参数是`int`指针。

**o**
匹配可选有符号八进制整数，其格式与`strtoul()`的主体序列期望的格式相同，base参数值为8。在没有大小修饰符的情况下，应用程序应确保相应参数是`unsigned`指针。

**u**
匹配可选有符号十进制整数，其格式与`strtoul()`的主体序列期望的格式相同，base参数值为10。在没有大小修饰符的情况下，应用程序应确保相应参数是`unsigned`指针。

**x**
匹配可选有符号十六进制整数，其格式与`strtoul()`的主体序列期望的格式相同，base参数值为16。在没有大小修饰符的情况下，应用程序应确保相应参数是`unsigned`指针。

**a, e, f, g**
匹配可选有符号浮点数、无穷大或NaN，其格式与`strtod()`的主体序列期望的格式相同。在没有大小修饰符的情况下，应用程序应确保相应参数是`float`指针。

如果`fprintf()`函数族为无穷大和NaN（以浮点格式编码的符号实体）生成字符串表示以支持IEEE Std 754-1985，`fscanf()`函数族应将它们识别为输入。

**s**
匹配非空白字节的字节序列。如果未指定'm'赋值分配字符，应用程序应确保相应参数是指向`char`、`signed char`或`unsigned char`数组初始字节的指针，该数组足够大以接受序列和自动添加的终止空字符代码。[CX]否则，应用程序应确保相应参数是指向`char`指针的指针。

如果存在l（ell）限定符，输入是以初始移位状态开始的字符序列。每个字符应转换为宽字符，就像通过调用`mbrtowc()`函数一样，转换状态由在第一个字符转换前初始化为零的`mbstate_t`对象描述。如果未指定'm'赋值分配字符，应用程序应确保相应参数是指向`wchar_t`数组的指针，该数组足够大以接受序列和自动添加的终止空宽字符。[CX]否则，应用程序应确保相应参数是指向`wchar_t`指针的指针。

**[**
从一组期望字节（扫描集）中匹配非空字节序列。在这种情况下，正常跳过空白字节应被抑制。如果未指定'm'赋值分配字符，应用程序应确保相应参数是指向`char`、`signed char`或`unsigned char`数组初始字节的指针，该数组足够大以接受序列和自动添加的终止空字节。[CX]否则，应用程序应确保相应参数是指向`char`指针的指针。

如果存在l（ell）限定符，输入是以初始移位状态开始的字符序列。序列中的每个字符应转换为宽字符，就像通过调用`mbrtowc()`函数一样，转换状态由在第一个字符转换前初始化为零的`mbstate_t`对象描述。如果未指定'm'赋值分配字符，应用程序应确保相应参数是指向`wchar_t`数组的指针，该数组足够大以接受序列和自动添加的终止空宽字符。[CX]否则，应用程序应确保相应参数是指向`wchar_t`指针的指针。

转换说明包括格式字符串中所有后续字节，直到并包括匹配的右方括号(']')。方括号之间的字节（扫描列表）组成扫描集，除非左方括号之后的字节是抑扬符（'^'），在这种情况下，扫描集包含不出现在抑扬符和右方括号之间扫描列表中的所有字节。如果转换说明以"[]"或"[^]"开始，右方括符包含在扫描列表中，下一个右方括符是结束转换说明的匹配右方括符；否则，第一个右方括符是结束转换说明的那个。如果'-'在扫描列表中，并且不是第一个字符，也不是第二个字符（其中第一个字符是'^'），也不是最后一个字符，行为是实现定义的。

**c**
匹配由字段宽度指定的数字的字节序列（如果转换说明中不存在字段宽度则为1）。不添加空字节。在这种情况下，正常跳过空白字节应被抑制。如果未指定'm'赋值分配字符，应用程序应确保相应参数是指向`char`、`signed char`或`unsigned char`数组初始字节的指针，该数组足够大以接受序列。[CX]否则，应用程序应确保相应参数是指向`char`指针的指针。

如果存在l（ell）限定符，输入应该是以初始移位状态开始的字符序列。序列中的每个字符转换为宽字符，就像通过调用`mbrtowc()`函数一样，转换状态由在第一个字符转换前初始化为零的`mbstate_t`对象描述。不添加空宽字符。如果未指定'm'赋值分配字符，应用程序应确保相应参数是指向`wchar_t`数组的指针，该数组足够大以接受生成的宽字符序列。[CX]否则，应用程序应确保相应参数是指向`wchar_t`指针的指针。

**p**
匹配实现定义的序列集合，该集合应与相应`fprintf()`函数的%p转换说明符产生的序列集合相同。应用程序应确保相应参数是指向`void`指针的指针。输入项的解释是实现定义的。如果输入项是同一程序执行期间早期转换的值，结果指针应与该值相等；否则，%p转换说明符的行为是未定义的。

**n**
不消耗输入。应用程序应确保相应参数是指向整数的指针，该整数将被写入此`fscanf()`函数调用迄今为止从输入中读取的字节数。执行%n转换说明符不应增加函数执行完成时返回的赋值计数。不应转换任何参数，但应消耗一个参数。

**%**
匹配单个'%'字符；不应进行赋值或转换。完整的转换说明应为%%。

## 返回值

成功完成时，这些函数应返回成功匹配和赋值的输入项数量；在早期匹配失败的情况下，此数量可以为零。如果输入在第一次匹配失败或转换之前结束，应返回EOF。如果发生读取错误，流的错误指示符应被设置，应返回EOF，并应设置`errno`以指示错误。

## 错误

有关函数应失败和可能失败的条件，请参阅底层`fgetc()`或`fgetwc()`函数的文档。此外，`fscanf()`函数可能在以下情况下失败：

* **[ENOMEM]** - 使用'm'赋值分配字符时没有足够的存储空间来保存转换后的值。

## 示例

```c
#include <stdio.h>

int main(void) {
    int i;
    float f;
    char s[100];

    /* 读取整数、浮点数和字符串 */
    if (fscanf(stdin, "%d %f %99s", &i, &f, s) == 3) {
        printf("Read: %d, %f, %s\n", i, f, s);
    }

    return 0;
}
```

## 应用程序使用

`fscanf()`函数族可用于需要从文件、标准输入或字符串读取和解析格式化输入的应用程序中。格式字符串提供了对输入解释和转换的灵活控制。

赋值分配字符'm'在输入大小事先未知时特别有用，因为它允许实现自动分配适当的内存。

## 原理

`fscanf()`函数为输入解析和转换提供了强大的机制。该设计允许：

* 通过格式规范对输入解析进行精确控制
* 使用'm'修饰符时为可变长度输入自动分配内存
* 支持窄字符和宽字符输入
* 为国际化应用程序提供编号参数规范

行为被仔细指定以确保在不同实现上获得一致的结果，同时保持与ISO C标准的兼容性。

## 未来方向

无。

## 另请参见

`fgetc()`, `fgetwc()`, `fprintf()`, `fread()`, `fseek()`, `getchar()`, `scanf()`, `setlocale()`, `sscanf()`, `strtod()`, `strtol()`, `strtoul()`, `ungetc()`