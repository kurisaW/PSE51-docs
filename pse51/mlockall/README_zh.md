# mlockall

## 概要

```c
#include <sys/mman.h>

int mlockall(int flags);
int munlockall(void);
```

## 描述

`mlockall()` 函数应使进程地址空间映射的所有页面在内存中保持驻留，直到被解锁、进程退出或 `exec` 执行另一个进程映像为止。`flags` 参数决定锁定的页面是当前由进程地址空间映射的页面、将来要映射的页面，还是两者兼有。`flags` 参数由以下一个或多个符号常量的按位包含 OR 构成，这些常量定义在 `<sys/mman.h>` 中：

- **MCL_CURRENT**
  锁定当前映射到进程地址空间的所有页面。

- **MCL_FUTURE**
  锁定将来映射到进程地址空间的所有页面，当这些映射建立时锁定。

如果指定了 MCL_FUTURE，并且对未来映射的自动锁定最终导致锁定的内存量超过可用物理内存的量或任何其他实现定义的限制，则行为是实现定义的。实现通知应用程序这些情况的方式也是实现定义的。

`munlockall()` 函数应解锁进程地址空间的所有当前映射页面。在调用 `munlockall()` 之后映射到进程地址空间的任何页面都不应被锁定，除非有中间的 `mlockall()` 调用指定了 MCL_FUTURE，或后续的 `mlockall()` 调用指定了 MCL_CURRENT。如果映射到进程地址空间的页面也映射到其他进程的地址空间并被这些进程锁定，则其他进程建立的锁定不受此进程调用 `munlockall()` 的影响。

在成功返回指定 MCL_CURRENT 的 `mlockall()` 函数后，进程地址空间的所有当前映射页面应在内存中驻留并被锁定。从 `munlockall()` 函数返回后，进程地址空间的所有当前映射页面应相对于进程地址空间被解锁。未锁定页面的内存驻留情况是未指定的。

使用 `mlockall()` 锁定进程内存需要适当的权限。

## 返回值

成功完成后，`mlockall()` 函数应返回零值。否则，不应锁定额外的内存，函数应返回值 -1 并设置 `errno` 以指示错误。`mlockall()` 失败对地址空间中先前存在的锁定的影响是未指定的。

如果实现支持，`munlockall()` 函数应始终返回零值。否则，函数应返回值 -1 并设置 `errno` 以指示错误。

## 错误

`mlockall()` 函数在以下情况下应失败：

- **[EAGAIN]**
  调用时操作标识的部分或全部内存无法被锁定。

- **[EINVAL]**
  `flags` 参数为零，或包含未实现的标志。

`mlockall()` 函数在以下情况下可能失败：

- **[ENOMEM]**
  锁定当前映射到进程地址空间的所有页面将超过进程可锁定内存量的实现定义限制。

- **[EPERM]**
  调用进程没有执行所请求操作的适当权限。

## 示例

无。

## 应用程序用法

无。

## 基本原理

无。

## 未来方向

无。

## 另请参见

[`exec`](exec.html), [`exit()`](exit.html), [`fork()`](fork.html), [`mlock()`](mlock.html), [`munmap()`](munmap.html)

XBD `<sys/mman.h>`

## 变更历史

首次发布于 Issue 5。为了与 POSIX 实时扩展对齐而包含。

### Issue 6

`mlockall()` 和 `munlockall()` 函数被标记为进程内存锁定选项的一部分。

[ENOSYS] 错误条件已被移除，因为如果实现不支持进程内存锁定选项，则不需要提供存根。

---
